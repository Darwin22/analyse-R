---
title: "Manipulation de données"
---

```{r options_communes, include=FALSE}
source("options_communes.R")
```

<div class="note">
La version originale de ce chapitre a été écrite par Julien Barnier dans le cadre du support de cours
[Introduction à R](https://github.com/juba/intro-r).
</div>

<div class="info">
Cette partie est un peu aride et pas forcément très intuitive. Elle aborde cependant la base de tous les
traitements et manipulation de données sous **R**, et mérite donc qu'on s'y arrête un moment, ou qu'on y
revienne un peu plus tard en cas de saturation...
</div>

## Variables{#variables}

Le type d'objet utilisé par **R** pour stocker des 
<dfn data-index="tableau de données">tableaux de données</dfn> s'appelle un 
<dfn lang="en">data frame</dfn>. Celui-ci comporte des <dfn data-index="observation">observations</dfn>
en ligne et des <dfn data-index="variable">variables</dfn> en colonnes. 
On accède aux variables d'un *data frame* avec l'opérateur 
`$`{data-package="base" data-rdocumentation="Extract"}.

Dans ce qui suit on travaillera sur le jeu de données tiré de l'enquête *Histoire de vie*, fourni avec
l'extension <strong class="package">questionr</strong>, mais aussi sur le jeu de données tiré du 
recensement 1999 et disponible dans la même extension.

```{r, warning=FALSE}
library(questionr)
data(hdv2003)
d <- hdv2003
data(rp99)
```

### Types de variables

On peut considérer qu'il existe quatre types principaux de variables dans **R** :

* les <dfn data-index="variable numérique">variables numériques</dfn><dfn data-index="numérique, variable"></dfn>
  ou <dfn data-index="variable quantitative">quantitatives</dfn><dfn data-index="quantitative, variable"> ;
* les <dfn data-index="facteur">facteurs</dfn>, qui prennent leurs valeurs dans un ensemble défini de 
  <dfn data-index="modalité">modalités</dfn>. Elles correspondent en général aux questions fermées d'un questionnaire ;
* les <dfn data-index="variable caractères">variables caractères</dfn><dfn data-index="caractère, variable"></dfn>
  ou <dfn data-index="variable texte">texte</dfn><dfn data-index="texte, variable"></dfn>, 
  qui contiennent des chaînes de caractères plus ou moins longues. On les utilise pour les questions ouvertes 
  ou les champs libres ;
* les <dfn data-index="variable booléenne">variables booléennes</dfn><dfn data-index="booléenne, variable"></dfn>
  ou <dfn data-index="variable logique">variables logiques</dfn><dfn data-index="logique, variable"></dfn>,
  qui ne peuvent prendre que la valeur vrai (`TRUE`) ou faux (`FALSE`). On les utilise dans **R** pour 
  les calculs et les recodages.

Pour connaître le type d'une variable donnée, on peut utiliser la fonction `class`{data-package="base"}.

Classe R      | Type de variable
------------- | -------------
<dfn lang="en">factor</dfn>    | facteur
<dfn lang="en">integer</dfn>   | numérique
<dfn lang="en">double</dfn>    | numérique
<dfn lang="en">numeric</dfn>   | numérique
<dfn lang="en">character</dfn> | caractère/texte
<dfn lang="en">logical</dfn>   | booléenne


```{r}
class(d$age)
class(d$sexe)
class(c(TRUE, TRUE, FALSE))
```


La fonction `str`{data-package="utils"} permet également d'avoir un listing de toutes les variables 
d'un tableau de données et indique le type de chacune d'elle.

```{r}
str(d)
```

<div class="note">
Il existe sous **R** un grand nombre d'autres types de variables définis de base ou via des extensions
pour gérer des informations particulières, telles que des dates par exemple. Nous n'aborderons pas
ces autres formes de variables dans ce chapitre.
</div>
### Renommer des variables

Une opération courante lorsqu'on a importé des variables depuis une source de données externe consiste
à renommer les variables importées. Sous **R** les noms de variables doivent être à la fois courts et explicites.

<div class="important">
Les noms de variables peuvent contenir des lettres, des chiffres (mais ils ne peuvent pas commencer par un
chiffre), les symboles `.` et `_` et doivent commencer par une lettre. **R** fait la différence entre les majuscules
et les minuscules, ce qui signifie que *x* et *X* sont deux noms de variable différents. 
On évitera également d'utiliser des caractères accentués dans les noms de variable. 
Comme les espaces ne sont pas autorisés, on pourra les remplacer par un point ou un tiret bas.
</div>

On peut lister les noms des variables d'un tableau de données (*data.frame*) à l'aide de la fonction `names`{data-package="base"} :

```{r}
names(d)
```

Cette fonction peut également être utilisée pour renommer l'ensemble des variables. Si par exemple
on souhaitait passer les noms de toutes les variables en majuscules, on pourrait faire :

```{r}
d.maj <- d
names(d.maj) <- c("ID", "AGE", "SEXE", "NIVETUD", "POIDS", "OCCUP", "QUALIF",
  "FRERES.SOEURS", "CLSO", "RELIG", "TRAV.IMP", "TRAV.SATISF", "HARD.ROCK",
  "LECTURE.BD", "PECHE.CHASSE", "CUISINE", "BRICOL", "CINEMA", "SPORT", "HEURES.TV")
summary(d.maj$SEXE)
```

Ce type de renommage peut être utile lorsqu'on souhaite passer en revue tous les noms de variables
d'un fichier importé pour les corriger le cas échéant. Pour faciliter un peu ce travail pas forcément
passionant, on peut utiliser la fonction `dput`{data-package="base"} :

```{r}
dput(names(d))
```

On obtient en résultat la liste des variables sous forme de vecteur déclaré. On n'a plus alors qu'à
copier/coller cette chaîne, rajouter `names(d) <-` devant et modifier un à un les noms des variables.

Si on souhaite seulement modifier le nom d'une variable, on peut utiliser la fonction
`rename.variable`{data-package="questionr"} de l'extension <strong class="package">questionr</strong>. 
Celle-ci prend en argument le tableau de données, le nom actuel de la variable
et le nouveau nom. Par exemple, si on veut renommer la variable *bricol* du tableau de données `d` en
*bricolage* :

```{r}
d <- rename.variable(d, "bricol", "bricolage")
table(d$bricolage)
```

### Facteurs

Parmi les différents types de variables, les <dfn data-index="facteur">facteurs</dfn> 
(<dfn lang="en">factor</dfn>) sont à la fois à part et très utilisés, car
ils vont correspondre à la plupart des variables issues d'une question fermée dans un questionnaire.

Les facteurs prennent leurs valeurs dans un ensemble de modalités prédéfinies et ne peuvent en prendre
d'autres. La liste des valeurs possibles est donnée par la fonction `levels`{data-package="base"} :

```{r}
levels(d$sexe)
```

Si on veut modifier la valeur du sexe du premier individu de notre tableau de données avec une valeur
non autorisée, on obient un message d'erreur et une valeur manquante est utilisée à la place :

```{r}
d$sexe[1] <- "Chihuahua"
d$sexe[1]
d$sexe[1] <- "Homme"
d$sexe[1]
```

On peut très facilement créer un facteur à partir d'une variable de type caractères avec la fonction
`factor`{data-package="base"} :

```{r}
v <- factor(c("H", "H", "F", "H"))
v
```

Par défaut, les niveaux d'un facteur nouvellement créés sont l'ensemble des valeurs de la variable
caractères, ordonnées par ordre alphabétique. Cette ordre des niveaux est utilisé à chaque fois qu'on
utilise des fonctions comme `table`{data-package="base"}, par exemple :

```{r}
table(v)
```

On peut modifier cet ordre au moment de la création du facteur en utilisant l'option `levels` :

```{r}
v <- factor(c("H", "H", "F", "H"), levels = c("H", "F"))
table(v)
```

On peut aussi modifier l'ordre des niveaux d'une variable déjà existante :

```{r}
d$qualif <- factor(d$qualif, levels = c("Ouvrier specialise", "Ouvrier qualifie",
  "Employe", "Technicien", "Profession intermediaire", "Cadre", "Autre"))
table(d$qualif)
```

<div class="astuce">
L'extension <strong class="package">questionr</strong> propose une *interface interactive* pour 
le réordonnancement des niveaux d'un facteur. Cette fonction, nommée `iorder`{data-package="questionr"}, 
vous permet de réordonner les modalités de manière graphique et de générer le code **R** correspondant.

Dans l'exemple précédant, si vous exécutez :

```{r, eval=FALSE}
iorder(d, "qualif")
```

**RStudio** devrait ouvrir une fenêtre semblable à celle de la figure ci-dessous.

![Interface de la commande iorder](images/capture_iorder.png)

Vous pouvez alors déplacer les modalités par glisser-déposer, vérifier le résultat dans l'onglet *Vérification*
et, une fois le résultat satisfaisant, récupérer le code généré pour l'inclure dans votre script.
</div>

On peut également modifier les niveaux eux-mêmes. Imaginons que l'on souhaite créer une nouvelle
variable *qualif.abr* contenant les noms abrégés des catégories socioprofessionnelles de *qualif*. On peut
alors procéder comme suit :

```{r}
d$qualif.abr <- factor(d$qualif, levels = c("Ouvrier specialise", "Ouvrier qualifie",
  "Employe", "Technicien", "Profession intermediaire", "Cadre", "Autre"),
 labels = c("OS", "OQ", "Empl", "Tech", "Interm", "Cadre", "Autre"))
table(d$qualif.abr)
```

Dans ce qui précède, le paramètre `levels` de `factor`{data-package="base"} permet de spécifier 
quels sont les niveaux retenus dans le facteur résultat, ainsi que leur ordre. 
Le paramètre `labels`, lui, permet de modifier les noms de
ces niveaux dans le facteur résultat. Il est donc capital d'indiquer les noms de `labels` exactement dans le
même ordre que les niveaux de `levels`. Pour s'assurer de ne pas avoir commis d'erreur, il est recommandé
d'effectuer un tableau croisé entre l'ancien et le nouveau facteur :

```{r}
table(d$qualif, d$qualif.abr)
```

On a donc ici un premier moyen d'effectuer un recodage des modalités d'une variable de type facteur.
D'autres méthodes existent, voir la section [Recodages](#recodages) ci-après.

À noter que par défaut, les valeurs manquantes ne sont pas considérées comme un niveau de facteur.
On peut cependant les transformer en niveau en utilisant la fonction 
`addNA`{data-package="base" data-rdocumentation="factor"}. 
Ceci signifie cependant qu'elle ne seront plus considérées comme manquantes par **R** mais
comme une modalité à part entière :

```{r}
summary(d$trav.satisf)
summary(addNA(d$trav.satisf))
```

La fonction `addNAstr`{data-package="questionr"} de l'extension <strong class="package">questionr</strong>
fait la même chose mais permet de spécifier l'étiquette de la modalité des valeurs manquantes.

```{r}
library(questionr)
summary(addNAstr(d$trav.satisf, "Manquant"))
```


## Indexation{#indexation}

L'<dfn>indexation</dfn> est l'une des fonctionnalités les plus puissantes mais aussi les plus difficiles à maîtriser de
**R**. Il s'agit d'opérations permettant de sélectionner des sous-ensembles d'observations et/ou de variables
en fonction de différents critères. L'indexation peut porter sur des vecteurs, des matrices ou des tableaux
de données.

Le principe est toujours le même : on indique, entre crochets et à la suite du nom de l'objet à indexer,
une série de conditions indiquant ce que l'on garde ou non. Ces conditions peuvent être de différents
types.

### Indexation directe

Le mode le plus simple d'indexation consiste à indiquer la position des éléments à conserver. Dans le
cas d'un vecteur cela permet de sélectionner un ou plusieurs éléments de ce vecteur.

Soit le vecteur suivant :

```{r}
v <- c("a", "b", "c", "d", "e", "f", "g")
```

Si on souhaite le premier élément du vecteur, on peut faire :

```{r}
v[1]
```

Si on souhaite les trois premiers éléments ou les éléments 2, 6 et 7 :

```{r}
v[1:3]
v[c(2, 6, 7)]
```

Si on veut le dernier élément :

```{r}
v[length(v)]
```

Dans le cas de matrices ou de tableaux de données, l'indexation prend deux arguments séparés par une
virgule : le premier concerne les lignes et le second les colonnes. Ainsi, si on veut l'élément correspondant
à la troisième ligne et à la cinquième colonne du tableau de données `d` :

```{r}
d[3, 5]
```

On peut également indiquer des vecteurs :

```{r}
d[1:3, 1:2]
```

Si on laisse l'un des deux critères vides, on sélectionne l'intégralité des lignes ou des colonnes. Ainsi
si l'on veut seulement la cinquième colonne ou les deux premières lignes :

```{r}
str(d[, 5])
str(d[1:2, ])
```

Enfin, si on préfixe les arguments avec le signe <kbd>-</kbd>, ceci signifie « tous les éléments sauf ceux
indiqués ». Si par exemple on veut tous les éléments de `v` sauf le premier :

```{r}
v[-1]
```

Bien sûr, tous ces critères se combinent et on peut stocker le résultat dans un nouvel objet. Dans cet
exemple `d2` contiendra les trois premières lignes de `d` ainsi que la 50^e^ ligne mais sans les colonnes 2 et 5 à 13.

```{r}
d2 <- d[c(1:3,50), -c(2, 5:13)]
str(d2)
```

### Indexation par nom

Un autre mode d'indexation consiste à fournir non pas un numéro mais un nom sous forme de chaîne
de caractères. On l'utilise couramment pour sélectionner les variables d'un tableau de données. Ainsi, les
deux écritures suivantes sont équivalentes^[Une différence entre les deux est que `$` admet une correspondance
partielle du nom de variable, si celle-ci est unique.
Ainsi, `d$cls` renverra bien la variable *clso*, tandis que `d$c` renverra `NULL`, 
du fait que plusieurs variables de *d* commencent par la lettre *c*.] :

```{r, results='hide'}
d$clso
d[, "clso"]
```

Là aussi on peut utiliser un vecteur pour sélectionner plusieurs noms et récupérer un « sous-tableau »
de données :

```{r, results='hide'}
d2 <- d[, c("id", "sexe", "age")]
```

Les noms peuvent également être utilisés pour les observations (lignes) d'un tableau de données si
celles-ci ont été munies d'un nom avec la fonction `row.names`{data-package="base"}. 
Par défaut les noms de ligne sont leur numéro d'ordre, 
mais on peut leur assigner comme nom la valeur d'une variable d'identifiant. Ainsi, on
peut assigner aux lignes du jeu de données `rp99` le nom des communes correspondantes :

```{r, results='hide'}
data(rp99)
row.names(rp99) <- rp99$nom
```
On peut alors accéder directement aux communes en donnant leur nom :

```{r, results='hide'}
rp99[c("VILLEURBANNE", "OULLINS"), ]
```

Par contre il n'est pas possible d'utiliser directement l'opérateur `-` comme pour l'indexation
directe. Pour exclure une colonne en fonction de son nom, on doit utiliser une autre forme d'indexation,
l'*indexation par condition*, expliquée dans la section suivante. On peut ainsi faire...

```{r, results='hide'}
d[, names(d) != "qualif"]
```

... pour sélectionner toutes les colonnes sauf celle qui s'appelle *qualif*.

### Indexation par condition

#### Tests et conditions

Une condition est une expression logique dont le résultat est soit `TRUE` (vrai) soit `FALSE` (faux).

Une condition comprend la plupart du temps un 
<dfn>opérateur de comparaison</dfn><dfn data-index="comparaison, opérateur"></dfn>. 
Les plus courants sont les suivants :

Opérateur de comparaison  | Signification
:-----------|:-------------
`==` | égal à
`!=` | différent de
`>` | strictement supérieur à
`<` | strictement inférieur à
`>=` | supérieur ou égal à
`<=` | inférieur ou égal à

Voyons tout de suite un exemple :

```{r}
str(d$sexe == "Homme")
```

Que s'est-il passé ? Nous avons fourni à **R** une condition qui signifie « la valeur de la variable *sexe*
vaut "Homme" ». Et il nous a renvoyé un vecteur avec autant d'éléments qu'il y'a d'observations dans `d`,
et dont la valeur est `TRUE` si l'observation correspond à un homme et `FALSE` dans les autres cas.

Prenons un autre exemple. On n'affichera cette fois que les premiers éléments de notre variable d'intérêt
à l'aide de la fonction `head`{data-package="utils"} :

```{r}
head(d$age)
head(d$age > 40)
```

On voit bien ici qu'à chaque élément du vecteur `d$age` dont la valeur est supérieure à 40 correspond
un élément `TRUE` dans le résultat de la condition.

On peut combiner ou modifier des conditions à l'aide des 
<dfn data-index="opérateur logique">opérateurs logiques</dfn><dfn data-index="logique, opérateur"></dfn> habituels :

Opérateur logique  |  Signification
:---------|:---------------
`&` | et logique
`|` | ou logique
`!` | négation logique

Comment les utilise-t-on ? Voyons tout de suite des exemples. Supposons que je veuille déterminer
quels sont dans mon échantillon les hommes ouvriers spécialisés :

```{r, results='hide'}
d$sexe == "Homme" & d$qualif == "Ouvrier specialise"
```

Si je souhaite identifier les personnes qui bricolent ou qui font la cuisine :

```{r, results='hide'}
d$bricol == "Oui" | d$cuisine == "Oui"
```

Si je souhaite isoler les femmes qui ont entre 20 et 34 ans :

```{r, results='hide'}
d$sexe == "Femme" & d$age >= 20 & d$age <= 34
```

Si je souhaite récupérer les enquêtés qui ne sont pas cadres, on peut utiliser l'une des deux formes
suivantes :

```{r, results='hide'}
d$qualif != "Cadre"
!(d$qualif == "Cadre")
```

Lorsqu'on mélange « et » et « ou » il est nécessaire d'utiliser des parenthèses pour différencier les
blocs. La condition suivante identifie les femmes qui sont soit cadre, soit employée :

```{r, results='hide'}
d$sexe == "Femme" & (d$qualif == "Employe" | d$qualif == "Cadre")
```

L'opérateur `%in%`{data-package="base" data-rdocumentation="match"} peut être très utile : 
il teste si une valeur fait partie des éléments d'un vecteur. Ainsi
on pourrait remplacer la condition précédente par :

```{r, results='hide'}
d$sexe == "Femme" & d$qualif %in% c("Employe", "Cadre")
```

Enfin, signalons qu'on peut utiliser les fonctions `table`{data-package="base"} ou `summary`{data-package="base"}
pour avoir une idée du résultat de notre condition :

```{r}
table(d$sexe)
table(d$sexe == "Homme")
summary(d$sexe == "Homme")
```

#### Utilisation pour l'indexation

L'utilisation des conditions pour l'indexation est assez simple : si on indexe un vecteur avec un vecteur
booléen, seuls les éléments correspondant à `TRUE` seront conservés.

Ainsi, si on fait :

```{r}
dh <- d[d$sexe == "Homme", ]
```

On obtiendra un nouveau tableau de données comportant l'ensemble des variables de `d`, mais seulement
les observations pour lesquelles la variable *sexe* vaut « Homme ».

La plupart du temps ce type d'indexation s'applique aux lignes, mais on peut aussi l'utiliser sur
les colonnes d'un tableau de données. L'exemple suivant, un peu compliqué, sélectionne uniquement les
variables dont le nom commence par *a* ou *s* :

```{r}
d2 <- d[, substr(names(d), 0, 1) %in% c("a", "s")]
```

On peut évidemment combiner les différents type d'indexation. L'exemple suivant sélectionne les
femmes de plus de 40 ans et ne conserve que les variables *qualif* et *relig*.

```{r}
d2 <- d[d$sexe == "Femme" & d$age > 40, c("qualif", "relig")]
```

#### Valeurs manquantes dans les conditions
Une remarque importante : quand l'un des termes d'une condition comporte une 
<dfn>valeur manquante</dfn><dfn data-index="manquante, valeur"></dfn> (`NA`), 
le résultat de cette condition n'est pas toujours `TRUE` ou `FALSE`, il peut aussi 
être à son tour une valeur manquante.

```{r}
v <- c(1:5, NA)
v
v > 3
```

On voit que le test `NA > 3` ne renvoie ni vrai ni faux, mais `NA`.

Le résultat d'une condition peut donc comporter un grand nombre de valeurs manquantes :

```{r}
summary(d$trav.satisf == "Satisfaction")
```

Une autre conséquence importante de ce comportement est qu'on ne peut pas utiliser l'opérateur 
l'expression `== NA` pour tester la présence de valeurs manquantes. 
On utilisera à la place la fonction *ad hoc* `is.na`{data-package="base" data-rdocumentation="NA"}.

On comprendra mieux le problème avec l'exemple suivant :

```{r}
v <- c(1, NA)
v
v == NA
is.na(v)
```

Pour compliquer encore un peu le tout, lorsqu'on utilise une condition pour l'indexation, si la condition
renvoie `NA`, **R** ne sélectionne pas l'élément mais retourne quand même la valeur `NA`. Ceci aura donc des
conséquences pour l'extraction de sous-populations (voir la section [sous-population](#sous_populations) 
ci-après).

### Indexation et assignation

Dans tous les exemples précédents, on a utilisé l'indexation pour extraire une partie d'un vecteur ou
d'un tableau de données, en plaçant l'opération d'indexation à droite de l'opérateur `<-`.

Mais l'indexation peut également être placée à gauche de cet opérateur d'<dfn>assignation</dfn>. 
Dans ce cas, les éléments sélectionnés par l'indexation sont alors remplacés par les valeurs indiquées 
à droite de l'opérateur `<-`.

Prenons donc un exemple simple :

```{r}
v <- 1:5
v
v[1] <- 3
v
```

Cette fois, au lieu d'utiliser quelque chose comme `x <- v[1]`, qui aurait placé la valeur du premier
élément de `v` dans `x`, on a utilisé `v[1] <- 3`, ce qui a mis à jour le premier élément de `v` avec la valeur 3.
Ceci fonctionne également pour les tableaux de données et pour les différents types d'indexation
évoqués précédemment :

```{r}
d[257, "sexe"] <- "Homme"
```

Enfin on peut modifier plusieurs éléments d'un seul coup soit en fournissant un vecteur, soit en profitant
du mécanisme de <dfn>recyclage</dfn>. Les deux commandes suivantes sont ainsi rigoureusement équivalentes :

```{r}
d[c(257, 438, 889), "sexe"] <- c("Homme", "Homme", "Homme")
d[c(257, 438, 889), "sexe"] <- "Homme"
```

On commence à voir comment l'utilisation de l'indexation par conditions et de l'assignation va nous
permettre de faire des recodages.

```{r}
d$gr.age[d$age >= 20 & d$age <= 30] <- "20-30 ans"
d$gr.age[is.na(d$age)] <- "Inconnu"
```

## Sous-populations {#sous_populations}

### Par indexation

La première manière de construire des sous-populations est d'utiliser l'indexation par conditions. On
peut ainsi facilement sélectionner une partie des observations suivant un ou plusieurs critères et placer le
résultat dans un nouveau tableau de données.

Par exemple si l'on souhaite isoler les hommes et les femmes :

```{r}
dh <- d[d$sexe == "Homme", ]
df <- d[d$sexe == "Femme", ]
table(d$sexe)
dim(dh)
dim(df)
```

On a à partir de là trois tableaux de données, `d` comportant la population totale, `dh` seulement les
hommes et `df` seulement les femmes.

On peut évidemment combiner plusieurs critères :

```{r}
dh.25 <- d[d$sexe == "Homme" & d$age <= 25, ]
dim(dh.25)
```

Si on utilise directement l'indexation, il convient cependant d'être extrêmement prudent avec les valeurs
manquantes. Comme indiqué précédemment, la présence d'une valeur manquante dans une condition
fait que celle-ci est évaluée en `NA` et qu'au final la ligne correspondante est conservée par l'indexation :

```{r}
summary(d$trav.satisf)
d.satisf <- d[d$trav.satisf == "Satisfaction", ]
dim(d.satisf)
```

Comme on le voit, ici `d.satisf` contient les individus ayant la modalité *Satisfaction* mais aussi ceux
ayant une valeur manquante `NA`. C'est pourquoi il faut toujours soit vérifier au préalable qu'on n'a pas
de valeurs manquantes dans les variables de la condition, soit exclure explicitement les `NA` de la manière
suivante :

```{r}
d.satisf <- d[d$trav.satisf == "Satisfaction" & !is.na(d$trav.satisf), ]
dim(d.satisf)
```

C'est notamment pour cette raison qu'on préfèrera le plus souvent utiliser la fonction `subset`{data-package="base"}.

### Fonction subset {#subset}

La fonction `subset`{data-package="base"} permet d'extraire des sous-populations de manière plus simple et un peu plus
intuitive que l'indexation directe.

Celle-ci prend trois arguments principaux :

* le nom de l'objet de départ ;
* une condition sur les observations (`subset`) ;
* éventuellement une condition sur les colonnes (`select`).

Reprenons tout de suite un exemple déjà vu :

```{r}
dh <- subset(d, sexe == "Homme")
df <- subset(d, sexe == "Femme")
```

L'utilisation de `subset`{data-package="base"} présente plusieurs avantages. 
Le premier est d'économiser quelques touches.
On n'est en effet pas obligé de saisir le nom du tableau de données 
dans la condition sur les lignes. Ainsi
les deux commandes suivantes sont équivalentes :

```{r}
dh <- subset(d, d$sexe == "Homme")
dh <- subset(d, sexe == "Homme")
```

Le second avantage est que `subset`{data-package="base"} s'occupe du problème 
des valeurs manquantes évoquées précédemment
et les exclut de lui-même, contrairement au comportement par défaut :

```{r}
summary(d$trav.satisf)
d.satisf <- d[d$trav.satisf == "Satisfaction", ]
dim(d.satisf)
d.satisf <- subset(d, trav.satisf == "Satisfaction")
dim(d.satisf)
```

Enfin, l'utilisation de l'argument `select` est simplifié pour l'expression de condition sur les colonnes.
On peut ainsi spécifier les noms de variable sans guillemets et leur appliquer directement l'opérateur
d'exclusion `-` :

```{r}
d2 <- subset(d, select = c(sexe, sport))
d2 <- subset(d, age > 25, select = -c(id, age, cinema))
```

### Fonction tapply {#tapply}

<div class="note">
Cette section documente une fonction qui peut être très utile, mais pas forcément indispensable au
départ.
</div>

La fonction `tapply`{data-package="base"} n'est qu'indirectement liée à la notion de sous-population, 
mais peut permettre d'éviter d'avoir à créer ces sous-populations dans certains cas.

Son fonctionnement est assez simple, mais pas forcément intuitif. La fonction prend trois arguments :
un vecteur, un facteur et une fonction. Elle applique ensuite la fonction aux éléments du vecteur 
correspondant à un même niveau du facteur. Vite, un exemple !

```{r}
tapply(d$age, d$sexe, mean)
```

Qu'est-ce que ça signifie ? Ici `tapply`{data-package="base"} a sélectionné toutes les observations 
correspondant à « Homme », puis appliqué la fonction `mean`{data-package="base"} 
aux valeurs de *age* correspondantes. Puis elle a fait de même pour les
observations correspondant à « Femme ». On a donc ici la moyenne d'âge chez les hommes et chez les
femmes.

On peut fournir à peu près n'importe quelle fonction à `tapply`{data-package="base"} :

```{r}
tapply(d$bricol, d$sexe, freq)
```

Les arguments supplémentaires fournis à `tapply`{data-package="base"} sont en fait fournis 
directement à la fonction appelée.

```{r}
tapply(d$bricol, d$sexe, freq, total = TRUE)
```

<div class="note">
La fonction `by`{data-package="base"} est un équivalent (pour les tableaux de données) de 
`tapply`{data-package="base"}. La présentation des résultats diffère légèrement.

```{r}
tapply(d$age, d$sexe, mean)
by(d$age, d$sexe, mean)
```
</div>

## Recodages{#recodages}

Le <dfn>recodage de variables</dfn><dfn data-index="variable, recodage"></dfn> est une opération extrêmement 
fréquente lors du traitement d'enquête. Celui-ci
utilise soit l'une des formes d'indexation décrites précédemment, soit des fonctions *ad hoc* de **R**.

On passe ici en revue différents types de recodage parmi les plus courants. Les exemples s'appuient,
comme précédemment, sur l'extrait de l'enquête *Histoire de vie* :

```{r}
library(questionr)
data(hdv2003)
d <- hdv2003
```

### Convertir une variable

Il peut arriver qu'on veuille transformer une variable d'un type dans un autre.

Par exemple, on peut considérer que la variable numérique *freres.soeurs* est une « fausse » variable
numérique et qu'une représentation sous forme de facteur serait plus adéquate. Dans ce cas il suffit de
faire appel à la fonction `factor`{data-package="base"} :

```{r}
d$fs.fac <- factor(d$freres.soeurs)
levels(d$fs.fac)
```

La conversion d'une variable caractères en facteur se fait de la même manière.

La conversion d'un facteur ou d'une variable numérique en variable caractères peut se faire à l'aide
de la fonction `as.character`{data-package="base" data-rdocumentation="character"} :

```{r}
d$fs.char <- as.character(d$freres.soeurs)
d$qualif.char <- as.character(d$qualif)
```

La conversion d'un facteur en caractères est fréquemment utilisé lors des recodages du fait qu'il est
impossible d'ajouter de nouvelles modalités à un facteur de cette manière. Par exemple, la première des
commandes suivantes génère un message d'avertissement, tandis que les deux autres fonctionnent :

```{r}
d.temp <- d
d.temp$qualif[d.temp$qualif == "Ouvrier specialise"] <- "Ouvrier"
d$qualif.char <- as.character(d$qualif)
d$qualif.char[d$qualif.char == "Ouvrier specialise"] <- "Ouvrier"
```

Dans le premier cas, le message d'avertissement indique que toutes les modalités « Ouvrier specialise »
de notre variable *qualif* ont été remplacées par des valeurs manquantes `NA`.

Enfin, une variable de type caractères dont les valeurs seraient des nombres peut être convertie en
variable numérique avec la fonction `as.numeric`{data-package="base" data-rdocumentation="numeric"}. 

```{r}
v <- c("1","3.1415","4","5.6","1","4")
v
as.numeric(v)
```

<div class="attention">
Lorsque l'on convertit un facteur avec `as.numeric`{data-package="base" data-rdocumentation="numeric"},
on obtient le numéro de chaque facteur (première modalité, seconde modalité, etc.).
Si la valeur numérique qui nous intéresse est en fait contenu dans le nom des modalités,
il faut connvertir au préalable notre facteur en variable textuelle.

```{r}
vf <- factor(v)
vf
as.numeric(vf)
as.numeric(as.character(vf))
```
</div>

### Découper une variable numérique en classes

Le premier type de recodage consiste à découper une variable de type numérique en un certain nombre
de classes. On utilise pour cela la fonction `cut`{data-package="base"}.

Celle-ci prend, outre la variable à découper, un certain nombre d'arguments :

* `breaks` indique soit le nombre de classes souhaité, soit, si on lui fournit un vecteur, les limites des
classes ;
* `labels` permet de modifier les noms de modalités attribués aux classes ;
* `include.lowest` et `right` influent sur la manière dont les valeurs situées à la frontière des classes
seront inclues ou exclues ;
* `dig.lab` indique le nombre de chiffres après la virgule à conserver dans les noms de modalités.

Prenons tout de suite un exemple et tentons de découper notre variable *age* en cinq classes et de
placer le résultat dans une nouvelle variable nommée *age5cl* :

```{r}
d$age5cl <- cut(d$age, 5)
table(d$age5cl)
```

Par défaut **R** nous a bien créé cinq classes d'amplitudes égales. La première classe va de 16,9 à 32,2
ans (en fait de 17 à 32), etc.

Les frontières de classe seraient plus présentables si elles utilisaient des nombres ronds. On va donc
spécifier manuellement le découpage souhaité, par tranches de 20 ans :

```{r}
d$age20 <- cut(d$age, c(0, 20, 40, 60, 80, 100))
table(d$age20)
```

On aurait pu tenir compte des âges extrêmes pour la première et la dernière valeur :

```{r}
range(d$age)
d$age20 <- cut(d$age, c(18, 20, 40, 60, 80, 97))
table(d$age20)
```

Les symboles dans les noms attribués aux classes ont leur importance : `(` signifie que la frontière de la
classe est exclue, tandis que `[` signifie qu'elle est incluse. Ainsi, `(20,40]` signifie « strictement supérieur
à 20 et inférieur ou égal à 40 ».

On remarque que du coup, dans notre exemple précédent, la valeur minimale, 18, est exclue de notre
première classe, et qu'une observation est donc absente de ce découpage. Pour résoudre ce problème on
peut soit faire commencer la première classe à 17, soit utiliser l'option `include.lowest=TRUE` :

```{r}
d$age20 <- cut(d$age, c(17, 20, 40, 60, 80, 97))
table(d$age20)
d$age20 <- cut(d$age, c(18, 20, 40, 60, 80, 97), include.lowest = TRUE)
table(d$age20)
```

On peut également modifier le sens des intervalles avec l'option `right=FALSE`, et indiquer manuellement
les noms des modalités avec `labels` :

```{r}
d$age20 <- cut(d$age, c(18, 20, 40, 60, 80, 97), right = FALSE, include.lowest = TRUE)
table(d$age20)
d$age20 <- cut(d$age, c(18, 20, 40, 60, 80, 97), include.lowest = TRUE, labels = c("<20ans", "21-40 ans", "41-60ans", "61-80ans", ">80ans"))
table(d$age20)
```

<div class="astuce">
L'extension <strong class="package">questionr</strong> propose une interface interactive à la fonction 
`cut`{data-package="base"}, nommée `icut`{data-package="questionr"}. Elle s'utilise de la manière
suivante :

```{r, eval=FALSE}
icut(d, age)
```

**RStudio** devrait ouvrir une fenêtre semblable à l'image ci-dessous.

![Capture d'écran d'icut](images/capture_icut.png)

Vous pouvez alors indiquer les limites de vos classes ainsi que quelques options complémentaires. Ces
limites sont représentées graphiquement sur l'histogramme de la variable d'origine.

L'onglet *Vérification* affiche un tri à plat et un graphique en barres de la nouvelle variable. Une fois le
résultat satisfaisant, vous pouvez récupérer le code généré pour l'inclure dans votre script.

L'extension <strong class="package">questionr</strong> propose aussi une fonction 
`quant.cut`{data-package="questionr"} permettant de découper une variable
numérique en un nombre de classes donné ayant des efffectifs semblables. 
Il suffit de lui passer le nombre de classes en argument :

```{r}
d$age6cl <- quant.cut(d$age, 6)
table(d$age6cl)
```

`quant.cut`{data-package="questionr"} admet les mêmes autres options que 
`cut`{data-package="base"} (`include.lowest`, `right`, `labels`... ).
</div>

### Regrouper les modalités d'une variable

Pour regrouper les modalités d'une variable qualitative (d'un facteur le plus souvent), on peut utiliser
directement l'indexation.

Ainsi, si on veut recoder la variable *qualif* dans une variable *qualif.reg* plus « compacte », on peut
utiliser :

```{r}
table(d$qualif)
d$qualif.reg[d$qualif == "Ouvrier specialise"] <- "Ouvrier"
d$qualif.reg[d$qualif == "Ouvrier qualifie"] <- "Ouvrier"
d$qualif.reg[d$qualif == "Employe"] <- "Employe"
d$qualif.reg[d$qualif == "Profession intermediaire"] <- "Intermediaire"
d$qualif.reg[d$qualif == "Technicien"] <- "Intermediaire"
d$qualif.reg[d$qualif == "Cadre"] <- "Cadre"
d$qualif.reg[d$qualif == "Autre"] <- "Autre"
table(d$qualif.reg)
```

On aurait pu représenter ce recodage de manière plus compacte, notamment en commençant par
copier le contenu de *qualif* dans *qualif.reg*, ce qui permet de ne pas s'occuper de ce qui ne change pas.

Il est cependant nécessaire de ne pas copier *qualif* sous forme de facteur, sinon on ne pourrait ajouter
de nouvelles modalités. On copie donc la version caractères de *qualif* grâce à la fonction 
`as.character`{data-package="base" data-rdocumentation="character"} :

```{r}
d$qualif.reg <- as.character(d$qualif)
d$qualif.reg[d$qualif == "Ouvrier specialise"] <- "Ouvrier"
d$qualif.reg[d$qualif == "Ouvrier qualifie"] <- "Ouvrier"
d$qualif.reg[d$qualif == "Profession intermediaire"] <- "Intermediaire"
d$qualif.reg[d$qualif == "Technicien"] <- "Intermediaire"
table(d$qualif.reg)
```

On peut faire une version encore plus compacte en utilisant l'opérateur logique *ou* (`|`) :

```{r}
d$qualif.reg <- as.character(d$qualif)
d$qualif.reg[d$qualif == "Ouvrier specialise" | d$qualif == "Ouvrier qualifie"] <- "Ouvrier"
d$qualif.reg[d$qualif == "Profession intermediaire" | d$qualif == "Technicien"] <- "Intermediaire"
table(d$qualif.reg)
```

Enfin, pour terminer ce petit tour d'horizon, on peut également remplacer l'opérateur `|` par `%in%`, qui
peut parfois être plus lisible :

```{r}
d$qualif.reg <- as.character(d$qualif)
d$qualif.reg[d$qualif %in% c("Ouvrier specialise", "Ouvrier qualifie")] <- "Ouvrier"
d$qualif.reg[d$qualif %in% c("Profession intermediaire", "Technicien")] <- "Intermediaire"
table(d$qualif.reg)
```

Dans tous les cas le résultat obtenu est une variable de type caractère. On pourra la convertir en
facteur par un simple :

```{r}
d$qualif.reg <- factor(d$qualif.reg)
```

Si on souhaite recoder les valeurs manquantes, il suffit de faire appel à la fonction 
`is.na`{data-package="base" data-rdocumentation="NA"} :

```{r}
table(d$trav.satisf)
d$trav.satisf.reg <- as.character(d$trav.satisf)
d$trav.satisf.reg[is.na(d$trav.satisf)] <- "Manquant"
table(d$trav.satisf.reg)
```

<div class="astuce">
<strong class="package">questionr</strong> propose une interface interactive pour le recodage 
d'une variable qualitative (renommage et regroupement de modalités). 
Cette fonction, nommée `irec`{data-package="questionr"}, s'utilise de la manière suivante :

```{r, eval=FALSE}
irec(d, qualif)
```

**RStudio** va alors ouvrir une fenêtre semblable à l'image ci-dessous :

![Capture de irec](images/capture_irec.png)

Vous pouvez alors sélectionner différentes options, et pour chaque ancienne modalité, indiquer la
nouvelle valeur correspondante. Pour regrouper des modalités, il suffit de leur assigner des nouvelles
valeurs identiques. Dans tous les cas n'hésitez pas à expérimenter, l'interface se contente de générer du
code **R** à copier/coller dans votre script mais ne l'exécute pas, et ne modifie donc jamais vos données !

L'onglet *Vérification* affiche un tri croisé de l'ancienne et de la nouvelle variable pour vérifier que le recodage
est correct. Une fois le résultat satisfaisant, vous pouvez récupérer le code généré dans l'onglet *Code* pour
l'inclure dans votre script.
</div>

### Variables calculées

La création d'une variable numérique à partir de calculs sur une ou plusieurs autres variables numériques
se fait très simplement.

Supposons que l'on souhaite calculer une variable indiquant l'écart entre le nombre d'heures passées
à regarder la télévision et la moyenne globale de cette variable. On pourrait alors faire :

```{r}
range(d$heures.tv, na.rm = TRUE)
mean(d$heures.tv, na.rm = TRUE)
d$ecart.heures.tv <- d$heures.tv - mean(d$heures.tv, na.rm = TRUE)
range(d$ecart.heures.tv, na.rm = TRUE)
mean(d$ecart.heures.tv, na.rm = TRUE)
```

Autre exemple tiré du jeu de données `rp99` : si on souhaite calculer le pourcentage d'actifs dans chaque
commune, on peut diviser la population active *pop.act* par la population totale *pop.tot*.

```{r}
data("rp99")
rp99$part.actifs <- rp99$pop.act/rp99$pop.tot * 100
```

### Combiner plusieurs variables

La combinaison de plusieurs variables se fait à l'aide des techniques d'indexation déjà décrites précédemment.
Le plus compliqué est d'arriver à formuler des conditions parfois complexes de manière
rigoureuse.

On peut ainsi vouloir combiner plusieurs variables qualitatives en une seule :

```{r}
d$act.manuelles <- NA
d$act.manuelles[d$cuisine == "Oui" & d$bricol == "Oui"] <- "Cuisine et Bricolage"
d$act.manuelles[d$cuisine == "Oui" & d$bricol == "Non"] <- "Cuisine seulement"
d$act.manuelles[d$cuisine == "Non" & d$bricol == "Oui"] <- "Bricolage seulement"
d$act.manuelles[d$cuisine == "Non" & d$bricol == "Non"] <- "Ni cuisine ni bricolage"
table(d$act.manuelles)
```

On peut également combiner variables qualitatives et variables quantitatives :

```{r}
d$age.sexe <- NA
d$age.sexe[d$sexe == "Homme" & d$age < 40] <- "Homme moins de 40 ans"
d$age.sexe[d$sexe == "Homme" & d$age >= 40] <- "Homme plus de 40 ans"
d$age.sexe[d$sexe == "Femme" & d$age < 40] <- "Femme moins de 40 ans"
d$age.sexe[d$sexe == "Femme" & d$age >= 40] <- "Femme plus de 40 ans"
table(d$age.sexe)
```

Les combinaisons de variables un peu complexes nécessitent parfois un petit travail de réflexion. En
particulier, l'ordre des commandes de recodage a parfois une influence dans le résultat final.

### Variables scores

Une variable score est une variable calculée en additionnant des poids accordés aux modalités d'une
série de variables qualitatives.

Pour prendre un exemple tout à fait arbitraire, imaginons que nous souhaitons calculer un score
d'activités extérieures. Dans ce score on considère que le fait d'aller au cinéma « pèse » 10, celui de
pêcher ou chasser vaut 30 et celui de faire du sport vaut 20. On pourrait alors calculer notre score de la
manière suivante :

```{r}
d$score.ext <- 0
d$score.ext[d$cinema == "Oui"] <- d$score.ext[d$cinema == "Oui"] + 10
d$score.ext[d$peche.chasse == "Oui"] <- d$score.ext[d$peche.chasse == "Oui"] + 30
d$score.ext[d$sport == "Oui"] <- d$score.ext[d$sport == "Oui"] + 20
table(d$score.ext)
```

Cette notation étant un peu lourde, on peut l'alléger un peu en utilisant la fonction `ifelse`{data-package="ifelse"}.
Celle-ci prend en argument une condition et deux valeurs.
Si la condition est vraie elle retourne la première valeur,
sinon elle retourne la seconde.

```{r}
d$score.ext <- 0
d$score.ext <- ifelse(d$cinema == "Oui", 10, 0) + ifelse(d$peche.chasse == "Oui", 30, 0) + ifelse(d$sport == "Oui", 20, 0)
table(d$score.ext)
```

### Vérification des recodages

Il est très important de vérifier, notamment après les recodages les plus complexes, qu'on a bien obtenu
le résultat escompté. Les deux points les plus sensibles étant les valeurs manquantes et les erreurs dans
les conditions.

Pour vérifier tout cela, le plus simple est sans doute de faire des tableaux croisés entre la variable
recodée et celles ayant servi au recodage, à l'aide des fonctions `table`{data-package="base"} ou
`xtabs`{data-package="stats"}, et de vérifier le nombre de valeurs manquantes dans la variable recodée 
avec `summary`{data-package="base"}, `freq`{data-package="questionr"} ou `table`{data-package="base"}.

Par exemple :

```{r}
d$act.manuelles <- NA
d$act.manuelles[d$cuisine == "Oui" & d$bricol == "Oui"] <- "Cuisine et Bricolage"
d$act.manuelles[d$cuisine == "Oui" & d$bricol == "Non"] <- "Cuisine seulement"
d$act.manuelles[d$cuisine == "Non" & d$bricol == "Oui"] <- "Bricolage seulement"
d$act.manuelles[d$cuisine == "Non" & d$bricol == "Non"] <- "Ni cuisine ni bricolage"
table(d$act.manuelles, d$cuisine)
table(d$act.manuelles, d$bricol)
```

## Tri de tables

La fonction `sort`{data-package="base"} permet de 
<dfn data-index="tri de tables">trier</dfn><dfn data-index="tableau de données, tri"></dfn> 
les éléments d'un vecteur.


```{r}
sort(c(2, 5, 6, 1, 8))
```

On peut appliquer cette fonction à une variable, mais celle-ci ne permet que d'ordonner les valeurs
de cette variable, et pas l'ensemble du tableau de données dont elle fait partie. Pour cela nous avons
besoin d'une autre fonction, nommée `order`{data-package="base"}. 
Celle-ci ne renvoie pas les valeurs du vecteur triées, mais les emplacements de ces valeurs.

Un exemple pour comprendre :

```{r}
order(c(15, 20, 10))
```

Le résultat renvoyé signifie que la plus petite valeur est la valeur située en 3^e^ position, suivie de
celle en 1^ère^ position et de celle en 2^e^ position. Tout cela ne paraît pas passionnant à première vue,
mais si on mélange ce résultat avec un peu d'indexation directe, ça devient intéressant...

```{r}
head(order(d$age))
```

Ce que cette fonction renvoie, c'est l'ordre dans lequel on doit placer les éléments de *age*, et donc par
extension les lignes de `d`, pour que la variable soit triée par ordre croissant. 
Par conséquent, si on fait :

```{r}
d.tri <- d[order(d$age), ]
```

Alors on a trié les lignes de d par ordre d'âge croissant ! Et si on fait un petit :

```{r}
head(d.tri, 3)
```

On a les caractéristiques des trois enquêtés les plus jeunes.

On peut évidemment trier par ordre décroissant en utilisant l'option `decreasing=TRUE`. On peut donc
afficher les caractéristiques des trois individus les plus âgés avec :

```{r}
head(d[order(d$age, decreasing = TRUE), ], 3)
```

On peut également trier selon plusieurs variables. Ainsi, si l'on souhaite trier le tableau par *sexe*
puis, au sein de chaque sexe, par *age* :

```{r}
d.tri <- d[order(d$sexe, d$age), ]
```

<div class="note">
Si l'on transmets une variable textuelle, le tri sera réalisé de manière alphabétique alors que si
l'on transmets un facteur, le tri sera effectué selon l'ordre des facteurs (que l'on peut visualiser
avec `levels`{data-package="base"}).
</div>

## Fusion de tables {#fusion_tables}

Lorsqu'on traite de grosses enquêtes, notamment les enquêtes de l'INSEE, on a souvent à gérer des
données réparties dans plusieurs tables, soit du fait de la construction du questionnaire, soit du fait de
contraintes techniques (fichiers **dbf** ou **Excel** limités à 256 colonnes, par exemple).

Une opération relativement courante consiste à 
<dfn data-index="fusion de tables">fusionner</dfn><dfn data-index="tableau de données, fusion"></dfn>
plusieurs tables pour regrouper tout ou
partie des données dans un unique tableau.

Nous allons simuler artificiellement une telle situation en créant deux tables à partir de l'extrait de
l'enquête *Histoire de vie* :

```{r}
data(hdv2003)
d <- hdv2003
dim(d)
d1 <- subset(d, select = c("id", "age", "sexe"))
dim(d1)
d2 <- subset(d, select = c("id", "clso"))
dim(d2)
```

On a donc deux tableaux de données, `d1` et `d2`, comportant chacun 2000 lignes et respectivement 3 et
2 colonnes. Comment les rassembler pour n'en former qu'un ?

Intuitivement, cela paraît simple. Il suffit de « coller » `d2` à la droite de `d1`, comme dans l'exemple
suivant.

<style type="text/css">
table.exemple_df td, 
table.exemple_df th {
  text-align: center;
  padding: 3px 10px;
}
table.exemple_df th {
  border-bottom: solid 1px #999;
}

table.exemple_df td + td,
table.exemple_df th + th {
  border-left: solid 1px #999;
}

table.exemple_operateur td {
  font-size: 3em;
  padding: 20px;
}
</style>

<table style="margin: 11px auto;">
<tr>

<td>
<table class="exemple_df">
<tr>
  <th>id</th><th>v1</th><th>v2</th>
</tr>
<tr>
  <td>1</td><td>H</td><td>12</td>
</tr>
<tr>
  <td>2</td><td>H</td><td>17</td>
</tr>
<tr>
  <td>3</td><td>F</td><td>41</td>
</tr>
<tr>
  <td>4</td><td>F</td><td>9</td>
</tr>
<tr>
  <td>...</td><td>...</td><td>...</td>
</tr>
</table>
</td>

<td>
<table class="exemple_operateur">
<tr><td>+</td></tr>
</table>
</td>

<td>
<table class="exemple_df">
<tr>
  <th>id</th><th>v3</th>
</tr>
<tr>
  <td>1</td><td>rouge</td>
</tr>
<tr>
  <td>2</td><td>bleu</td>
</tr>
<tr>
  <td>3</td><td>bleu</td>
</tr>
<tr>
  <td>4</td><td>rouge</td>
</tr>
<tr>
  <td>...</td><td>...</td><td>...</td>
</tr>
</table>
</td>

<td>
<table class="exemple_operateur">
<tr><td>=</td></tr>
</table>
</td>

<td>
<table class="exemple_df">
<tr>
  <th>id</th><th>v1</th><th>v2</th><th>v3</th>
</tr>
<tr>
  <td>1</td><td>H</td><td>12</td><td>rouge</td>
</tr>
<tr>
  <td>2</td><td>H</td><td>17</td><td>bleu</td>
</tr>
<tr>
  <td>3</td><td>F</td><td>41</td><td>bleu</td>
</tr>
<tr>
  <td>4</td><td>F</td><td>9</td><td>rouge</td>
</tr>
<tr>
  <td>...</td><td>...</td><td>...</td><td>...</td>
</tr>
</table>
</td>

</tr>
</table>

Cela semble fonctionner. La fonction qui permet d'effectuer cette opération sous **R** 
s'appelle `cbind`{data-package="base"}, elle « colle » des tableaux côte à côte en regroupant 
leurs colonnes^[L'équivalent de `cbind`{data-package="base"} pour les lignes s'appelle 
`rbind`{data-package="base" data-rdocumentation="cbind"}.].

```{r}
head(cbind(d1, d2))
```

À part le fait qu'on a une colonne *id* en double, le résultat semble satisfaisant. À première vue
seulement. Imaginons maintenant que nous avons travaillé sur `d1` et `d2`, et que nous avons ordonné les
lignes de `d1` selon l'âge des enquêtés :

```{r}
d1 <- d1[order(d1$age), ]
```

Répétons l'opération de collage :

```{r}
head(cbind(d1, d2))
```

Que constate-t-on ? La présence de la variable *id* en double nous permet de voir que les identifiants
ne coïncident plus ! En regroupant nos colonnes nous avons donc attribué à des individus les réponses
d'autres individus.

La commande `cbind`{data-package="base"} ne peut en effet fonctionner que si les deux tableaux ont exactement
le même nombre de lignes, et dans le même ordre, ce qui n'est pas le cas ici.

On va donc être obligé de pocéder à une <dfn>fusion</dfn> des deux tableaux, qui va permettre de rendre à
chaque ligne ce qui lui appartient. Pour cela nous avons besoin d'un identifiant qui permet d'identifier
chaque ligne de manière unique et qui doit être présent dans tous les tableaux. Dans notre cas, c'est
plutôt rapide, il s'agit de la variable *id*.

Une fois l'identifiant identifié^[Si vous me passez l'expression...], 
on peut utiliser la commande `merge`{data-package="base"}. Celle-ci va fusionner les deux
tableaux en supprimant les colonnes en double et en regroupant les lignes selon leurs identifiants :

```{r}
d.complet <- merge(d1, d2, by = "id")
head(d.complet)
```

Ici l'utilisation de la fonction `merge`{data-package="base"} est plutôt simple car nous sommes 
dans le cas de figure idéal : les lignes correspondent parfaitement et l'identifiant est clairement 
identifié. Parfois les choses peuvent être un peu plus compliquées :

* parfois les identifiants n'ont pas le même nom dans les deux tableaux. On peut alors les spécifier
  par les options `by.x` et `by.y` ;
* parfois les deux tableaux comportent des colonnes (hors identifiants) ayant le même nom. 
  `merge`{data-package="base"} conserve dans ce cas ces deux colonnes mais les renomme en 
  les suffixant par *.x* pour celles provenant du premier tableau et *.y* pour celles du second ;
* parfois on n'a pas d'identifiant unique préétabli, mais on en construit un à partir de plusieurs
  variables. On peut alors donner un vecteur en paramètres de l'option `by`, par exemple
  `by=c("nom","prenom","date.naissance")`.
  
Une subtilité supplémentaire intervient lorsque les deux tableaux fusionnés n'ont pas exactement les
mêmes lignes. Par défaut, `merge`{data-package="base"} ne conserve que les lignes présentes dans les deux tableaux :

<table style="margin: 11px auto;">
<tr>

<td>
<table class="exemple_df">
<tr>
  <th>id</th><th>v1</th>
</tr>
<tr>
  <td>1</td><td>H</td>
</tr>
<tr>
  <td>2</td><td>H</td>
</tr>
<tr>
  <td>3</td><td>F</td>
</tr>
</table>
</td>

<td>
<table class="exemple_operateur">
<tr><td>+</td></tr>
</table>
</td>

<td>
<table class="exemple_df">
<tr>
  <th>id</th><th>v2</th>
</tr>
<tr>
  <td>1</td><td>10</td>
</tr>
<tr>
  <td>2</td><td>15</td>
</tr>
<tr>
  <td>5</td><td>31</td>
</tr>
</table>
</td>

<td>
<table class="exemple_operateur">
<tr><td>=</td></tr>
</table>
</td>

<td>
<table class="exemple_df">
<tr>
  <th>id</th><th>v1</th><th>v2</th>
</tr>
<tr>
  <td>1</td><td>H</td><td>10</td>
</tr>
<tr>
  <td>2</td><td>H</td><td>15</td>
</tr>
</table>
</td>

</tr>
</table>

On peut cependant modifier ce comportement avec les options `all.x` et `all.y`.

Ainsi, `all.x=TRUE` indique de conserver toutes les lignes du premier tableau. 
Dans ce cas `merge`{data-package="base"} donne une valeur `NA`
pour ces lignes aux colonnes provenant du second tableau. Ce qui donnerait :

<table style="margin: 11px auto;">
<tr>

<td>
<table class="exemple_df">
<tr>
  <th>id</th><th>v1</th>
</tr>
<tr>
  <td>1</td><td>H</td>
</tr>
<tr>
  <td>2</td><td>H</td>
</tr>
<tr>
  <td>3</td><td>F</td>
</tr>
</table>
</td>

<td>
<table class="exemple_operateur">
<tr><td>+</td></tr>
</table>
</td>

<td>
<table class="exemple_df">
<tr>
  <th>id</th><th>v2</th>
</tr>
<tr>
  <td>1</td><td>10</td>
</tr>
<tr>
  <td>2</td><td>15</td>
</tr>
<tr>
  <td>5</td><td>31</td>
</tr>
</table>
</td>

<td>
<table class="exemple_operateur">
<tr><td>=</td></tr>
</table>
</td>

<td>
<table class="exemple_df">
<tr>
  <th>id</th><th>v1</th><th>v2</th>
</tr>
<tr>
  <td>1</td><td>H</td><td>10</td>
</tr>
<tr>
  <td>2</td><td>H</td><td>15</td>
</tr>
<tr>
  <td>3</td><td>F</td><td>`NA`</td>
</tr>
</table>
</td>

</tr>
</table>

L'option `all.y=TRUE` fait la même chose en conservant toutes les lignes du second tableau. 

<table style="margin: 11px auto;">
<tr>

<td>
<table class="exemple_df">
<tr>
  <th>id</th><th>v1</th>
</tr>
<tr>
  <td>1</td><td>H</td>
</tr>
<tr>
  <td>2</td><td>H</td>
</tr>
<tr>
  <td>3</td><td>F</td>
</tr>
</table>
</td>

<td>
<table class="exemple_operateur">
<tr><td>+</td></tr>
</table>
</td>

<td>
<table class="exemple_df">
<tr>
  <th>id</th><th>v2</th>
</tr>
<tr>
  <td>1</td><td>10</td>
</tr>
<tr>
  <td>2</td><td>15</td>
</tr>
<tr>
  <td>5</td><td>31</td>
</tr>
</table>
</td>

<td>
<table class="exemple_operateur">
<tr><td>=</td></tr>
</table>
</td>

<td>
<table class="exemple_df">
<tr>
  <th>id</th><th>v1</th><th>v2</th>
</tr>
<tr>
  <td>1</td><td>H</td><td>10</td>
</tr>
<tr>
  <td>2</td><td>H</td><td>15</td>
</tr>
<tr>
  <td>5</td><td>`NA`</td><td>31</td>
</tr>
</table>
</td>

</tr>
</table>

Enfin, on peut décider de conserver toutes les lignes des deux tableaux en utilisant à la 
fois `all.x=TRUE` et `all.y=TRUE`, ce qui donne :

<table style="margin: 11px auto;">
<tr>

<td>
<table class="exemple_df">
<tr>
  <th>id</th><th>v1</th>
</tr>
<tr>
  <td>1</td><td>H</td>
</tr>
<tr>
  <td>2</td><td>H</td>
</tr>
<tr>
  <td>3</td><td>F</td>
</tr>
</table>
</td>

<td>
<table class="exemple_operateur">
<tr><td>+</td></tr>
</table>
</td>

<td>
<table class="exemple_df">
<tr>
  <th>id</th><th>v2</th>
</tr>
<tr>
  <td>1</td><td>10</td>
</tr>
<tr>
  <td>2</td><td>15</td>
</tr>
<tr>
  <td>5</td><td>31</td>
</tr>
</table>
</td>

<td>
<table class="exemple_operateur">
<tr><td>=</td></tr>
</table>
</td>

<td>
<table class="exemple_df">
<tr>
  <th>id</th><th>v1</th><th>v2</th>
</tr>
<tr>
  <td>1</td><td>H</td><td>10</td>
</tr>
<tr>
  <td>2</td><td>H</td><td>15</td>
</tr>
<tr>
  <td>3</td><td>F</td><td>`NA`</td>
</tr>
<tr>
  <td>5</td><td>`NA`</td><td>31</td>
</tr>
</table>
</td>

</tr>
</table>

Parfois, l'un des identifiants est présent à plusieurs reprises dans l'un des tableaux (par exemple
lorsque l'une des tables est un ensemble de ménages et que l'autre décrit l'ensemble des individus de ces
ménages). Dans ce cas les lignes de l'autre table sont dupliquées autant de fois que nécessaires :

<table style="margin: 11px auto;">
<tr>

<td>
<table class="exemple_df">
<tr>
  <th>id</th><th>v1</th>
</tr>
<tr>
  <td>1</td><td>H</td>
</tr>
<tr>
  <td>2</td><td>H</td>
</tr>
<tr>
  <td>3</td><td>F</td>
</tr>
</table>
</td>

<td>
<table class="exemple_operateur">
<tr><td>+</td></tr>
</table>
</td>

<td>
<table class="exemple_df">
<tr>
  <th>id</th><th>v2</th>
</tr>
<tr>
  <td>1</td><td>10</td>
</tr>
<tr>
  <td>1</td><td>18</td>
</tr>
<tr>
  <td>1</td><td>21</td>
</tr>
<tr>
  <td>2</td><td>15</td>
</tr>
<tr>
  <td>3</td><td>42</td>
</tr>
</table>
</td>

<td>
<table class="exemple_operateur">
<tr><td>=</td></tr>
</table>
</td>

<td>
<table class="exemple_df">
<tr>
  <th>id</th><th>v1</th><th>v2</th>
</tr>
<tr>
  <td>1</td><td>H</td><td>10</td>
</tr>
<tr>
  <td>1</td><td>H</td><td>18</td>
</tr>
<tr>
  <td>1</td><td>H</td><td>21</td>
</tr>
<tr>
  <td>2</td><td>H</td><td>15</td>
</tr>
<tr>
  <td>3</td><td>F</td><td>42</td>
</tr>
</table>
</td>

</tr>
</table>

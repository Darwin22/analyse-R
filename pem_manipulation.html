<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />



<title>Manipulation de données</title>

<script src="libs/jquery-1.11.0/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="libs/bootstrap-3.3.1/css/flatly.min.css" rel="stylesheet" />
<script src="libs/bootstrap-3.3.1/js/bootstrap.min.js"></script>
<script src="libs/bootstrap-3.3.1/shim/html5shiv.min.js"></script>
<script src="libs/bootstrap-3.3.1/shim/respond.min.js"></script>
<link rel="stylesheet" href="./include/analyse-R.css" />


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>



</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img { 
  max-width:100%; 
  height: auto; 
}
</style>
<div class="container-fluid main-container">


<div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href=".">analyse-R</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li><a href="index.html">Accueil</a></li>
        <li class="dropdown">
          <a href="pem" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Prise en main <span class="caret"></span></a>
          <ul class="dropdown-menu" role="menu">
            <li><a href="pem_manipulation.html">Manipulation de données</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="analyses" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Analyses <span class="caret"></span></a>
          <ul class="dropdown-menu" role="menu">
            <li><a href="analyses_stat_biv.html">Statistique bivariée</a></li>
            <li><a href="analyses_reglog.html">Régression logistique</a></li>
            <li><a href="analyses_donnees_pond.html">Données pondérées</a></li>
            <li><a href="analyses_acm.html">Analyse des correspondances multiples (ACM)</a></li>
            <li><a href="analyses_cah.html">Classification ascendante hiérarchique (CAH)</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a href="astuces" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Astuces <span class="caret"></span></a>
          <ul class="dropdown-menu" role="menu">
            <li><a href="astuces_age.html">Calculer un âge</a></li>
          </ul>
        </li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li class="dropdown">
          <a href="participer" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Participer <span class="caret"></span></a>
          <ul class="dropdown-menu" role="menu">
              <li><a href="https://github.com/larmarange/analyse-R">analyse-R sur GitHub</a></li>
          </ul>
        </li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">
<h1 class="title">Manipulation de données</h1>
</div>

<div id="TOC">
<ul>
<li><a href="#variables">Variables</a><ul>
<li><a href="#types-de-variables">Types de variables</a></li>
<li><a href="#renommer-des-variables">Renommer des variables</a></li>
<li><a href="#facteurs">Facteurs</a></li>
</ul></li>
<li><a href="#indexation">Indexation</a><ul>
<li><a href="#indexation-directe">Indexation directe</a></li>
<li><a href="#indexation-par-nom">Indexation par nom</a></li>
<li><a href="#indexation-par-condition">Indexation par condition</a></li>
<li><a href="#indexation-et-assignation">Indexation et assignation</a></li>
</ul></li>
<li><a href="#sous-populations">Sous-populations</a><ul>
<li><a href="#par-indexation">Par indexation</a></li>
<li><a href="#subset">Fonction subset</a></li>
<li><a href="#tapply">Fonction tapply</a></li>
</ul></li>
<li><a href="#recodages">Recodages</a><ul>
<li><a href="#convertir-une-variable">Convertir une variable</a></li>
<li><a href="#decouper-une-variable-numerique-en-classes">Découper une variable numérique en classes</a></li>
<li><a href="#regrouper-les-modalites-dune-variable">Regrouper les modalités d’une variable</a></li>
<li><a href="#variables-calculees">Variables calculées</a></li>
<li><a href="#combiner-plusieurs-variables">Combiner plusieurs variables</a></li>
<li><a href="#variables-scores">Variables scores</a></li>
<li><a href="#verification-des-recodages">Vérification des recodages</a></li>
</ul></li>
<li><a href="#tri-de-tables">Tri de tables</a></li>
<li><a href="#fusion-de-tables">Fusion de tables</a></li>
</ul>
</div>

<div class="note">
La version originale de ce chapitre a été écrite par Julien Barnier dans le cadre du support de cours <a href="https://github.com/juba/intro-r">Introduction à R</a>.
</div>
<div class="info">
Cette partie est un peu aride et pas forcément très intuitive. Elle aborde cependant la base de tous les traitements et manipulation de données sous <strong>R</strong>, et mérite donc qu’on s’y arrête un moment, ou qu’on y revienne un peu plus tard en cas de saturation. . .
</div>
<div id="variables" class="section level2">
<h2>Variables</h2>
<p>Le type d’objet utilisé par <strong>R</strong> pour stocker des tableaux de données s’appelle un <em>data frame</em>. Celui-ci comporte des observations en ligne et des variables en colonnes. On accède aux variables d’un <em>data frame</em> avec l’opérateur <code>$</code>.</p>
<p>Dans ce qui suit on travaillera sur le jeu de données tiré de l’enquête <em>Histoire de vie</em>, fourni avec l’extension <strong class="package">questionr</strong>, mais aussi sur le jeu de données tiré du recensement 1999 et disponible dans la même extension.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(questionr)
<span class="kw">data</span>(hdv2003)
d &lt;-<span class="st"> </span>hdv2003
<span class="kw">data</span>(rp99)</code></pre>
<div id="types-de-variables" class="section level3">
<h3>Types de variables</h3>
<p>On peut considérer qu’il existe quatre type de variables dans <strong>R</strong> :</p>
<ul>
<li>les variables <em>numériques</em>, ou quantitatives ;</li>
<li>les <em>facteurs</em>, qui prennent leurs valeurs dans un ensemble défini de modalités. Elles correspondent en général aux questions fermées d’un questionnaire ;</li>
<li>les variables <em>caractères</em> ou <em>texte</em>, qui contiennent des chaînes de caractères plus ou moins longues. On les utilise pour les questions ouvertes ou les champs libres ;</li>
<li>les variables <em>booléennes</em>, qui ne peuvent prendre que la valeur vrai (<code>TRUE</code>) ou faux (<code>FALSE</code>). On les utilise dans <strong>R</strong> pour les calculs et les recodages.</li>
</ul>
<p>Pour connaître le type d’une variable donnée, on peut utiliser la fonction <code data-package="base">class</code>.</p>
<table>
<thead>
<tr class="header">
<th align="left">Classe R</th>
<th align="left">Type de variable</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">factor</td>
<td align="left">facteur</td>
</tr>
<tr class="even">
<td align="left">integer</td>
<td align="left">numérique</td>
</tr>
<tr class="odd">
<td align="left">double</td>
<td align="left">numérique</td>
</tr>
<tr class="even">
<td align="left">numeric</td>
<td align="left">numérique</td>
</tr>
<tr class="odd">
<td align="left">character</td>
<td align="left">caractère/texte</td>
</tr>
<tr class="even">
<td align="left">logical</td>
<td align="left">booléenne</td>
</tr>
</tbody>
</table>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(d$age)</code></pre>
<pre><code>[1] &quot;integer&quot;</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(d$sexe)</code></pre>
<pre><code>[1] &quot;factor&quot;</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">TRUE</span>, <span class="ot">FALSE</span>))</code></pre>
<pre><code>[1] &quot;logical&quot;</code></pre>
<p>La fonction <code data-package="utils">str</code> permet également d’avoir un listing de toutes les variables d’un tableau de données et indique le type de chacune d’elle.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(d)</code></pre>
<pre><code>&#39;data.frame&#39;:   2000 obs. of  20 variables:
 $ id           : int  1 2 3 4 5 6 7 8 9 10 ...
 $ age          : int  28 23 59 34 71 35 60 47 20 28 ...
 $ sexe         : Factor w/ 2 levels &quot;Homme&quot;,&quot;Femme&quot;: 2 2 1 1 2 2 2 1 2 1 ...
 $ nivetud      : Factor w/ 8 levels &quot;N&#39;a jamais fait d&#39;etudes&quot;,..: 8 NA 3 8 3 6 3 6 NA 7 ...
 $ poids        : num  2634 9738 3994 5732 4329 ...
 $ occup        : Factor w/ 7 levels &quot;Exerce une profession&quot;,..: 1 3 1 1 4 1 6 1 3 1 ...
 $ qualif       : Factor w/ 7 levels &quot;Ouvrier specialise&quot;,..: 6 NA 3 3 6 6 2 2 NA 7 ...
 $ freres.soeurs: int  8 2 2 1 0 5 1 5 4 2 ...
 $ clso         : Factor w/ 3 levels &quot;Oui&quot;,&quot;Non&quot;,&quot;Ne sait pas&quot;: 1 1 2 2 1 2 1 2 1 2 ...
 $ relig        : Factor w/ 6 levels &quot;Pratiquant regulier&quot;,..: 4 4 4 3 1 4 3 4 3 2 ...
 $ trav.imp     : Factor w/ 4 levels &quot;Le plus important&quot;,..: 4 NA 2 3 NA 1 NA 4 NA 3 ...
 $ trav.satisf  : Factor w/ 3 levels &quot;Satisfaction&quot;,..: 2 NA 3 1 NA 3 NA 2 NA 1 ...
 $ hard.rock    : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 1 1 1 1 1 1 1 1 1 ...
 $ lecture.bd   : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 1 1 1 1 1 1 1 1 1 ...
 $ peche.chasse : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 1 1 1 1 1 2 2 1 1 ...
 $ cuisine      : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 2 1 1 2 1 1 2 2 1 1 ...
 $ bricol       : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 1 1 2 1 1 1 2 1 1 ...
 $ cinema       : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 2 1 2 1 2 1 1 2 2 ...
 $ sport        : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 2 2 2 1 2 1 1 1 2 ...
 $ heures.tv    : num  0 1 0 2 3 2 2.9 1 2 2 ...</code></pre>
</div>
<div id="renommer-des-variables" class="section level3">
<h3>Renommer des variables</h3>
<p>Une opération courante lorsqu’on a importé des variables depuis une source de données externe consiste à renommer les variables importées. Sous <strong>R</strong> les noms de variables doivent être à la fois courts et explicites.</p>
<div class="important">
Les noms de variables peuvent contenir des lettres, des chiffres (mais ils ne peuvent pas commencer par un chiffre), les symboles <code>.</code> et <code>_</code> et doivent commencer par une lettre. <strong>R</strong> fait la différence entre les majuscules et les minuscules, ce qui signifie que <em>x</em> et <strong>X</strong> sont deux noms de variable différents. On évitera également d’utiliser des caractères accentués dans les noms de variable. Comme les espaces ne sont pas autorisés, on pourra les remplacer par un point ou un tiret bas.
</div>
<p>On peut lister les noms des variables d’un tableau de données (<em>data.frame</em>) à l’aide de la fonction <code data-package="base">names</code> :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(d)</code></pre>
<pre><code> [1] &quot;id&quot;            &quot;age&quot;           &quot;sexe&quot;          &quot;nivetud&quot;      
 [5] &quot;poids&quot;         &quot;occup&quot;         &quot;qualif&quot;        &quot;freres.soeurs&quot;
 [9] &quot;clso&quot;          &quot;relig&quot;         &quot;trav.imp&quot;      &quot;trav.satisf&quot;  
[13] &quot;hard.rock&quot;     &quot;lecture.bd&quot;    &quot;peche.chasse&quot;  &quot;cuisine&quot;      
[17] &quot;bricol&quot;        &quot;cinema&quot;        &quot;sport&quot;         &quot;heures.tv&quot;    </code></pre>
<p>Cette fonction peut également être utilisée pour renommer l’ensemble des variables. Si par exemple on souhaitait passer les noms de toutes les variables en majuscules, on pourrait faire :</p>
<pre class="sourceCode r"><code class="sourceCode r">d.maj &lt;-<span class="st"> </span>d
<span class="kw">names</span>(d.maj) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;ID&quot;</span>, <span class="st">&quot;AGE&quot;</span>, <span class="st">&quot;SEXE&quot;</span>, <span class="st">&quot;NIVETUD&quot;</span>, <span class="st">&quot;POIDS&quot;</span>, <span class="st">&quot;OCCUP&quot;</span>, <span class="st">&quot;QUALIF&quot;</span>, 
    <span class="st">&quot;FRERES.SOEURS&quot;</span>, <span class="st">&quot;CLSO&quot;</span>, <span class="st">&quot;RELIG&quot;</span>, <span class="st">&quot;TRAV.IMP&quot;</span>, <span class="st">&quot;TRAV.SATISF&quot;</span>, <span class="st">&quot;HARD.ROCK&quot;</span>, 
    <span class="st">&quot;LECTURE.BD&quot;</span>, <span class="st">&quot;PECHE.CHASSE&quot;</span>, <span class="st">&quot;CUISINE&quot;</span>, <span class="st">&quot;BRICOL&quot;</span>, <span class="st">&quot;CINEMA&quot;</span>, <span class="st">&quot;SPORT&quot;</span>, <span class="st">&quot;HEURES.TV&quot;</span>)
<span class="kw">summary</span>(d.maj$SEXE)</code></pre>
<pre><code>Homme Femme 
  899  1101 </code></pre>
<p>Ce type de renommage peut être utile lorsqu’on souhaite passer en revue tous les noms de variables d’un fichier importé pour les corriger le cas échéant. Pour faciliter un peu ce travail pas forcément passionant, on peut utiliser la fonction <code data-package="base">dput</code> :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">dput</span>(<span class="kw">names</span>(d))</code></pre>
<pre><code>c(&quot;id&quot;, &quot;age&quot;, &quot;sexe&quot;, &quot;nivetud&quot;, &quot;poids&quot;, &quot;occup&quot;, &quot;qualif&quot;, 
&quot;freres.soeurs&quot;, &quot;clso&quot;, &quot;relig&quot;, &quot;trav.imp&quot;, &quot;trav.satisf&quot;, 
&quot;hard.rock&quot;, &quot;lecture.bd&quot;, &quot;peche.chasse&quot;, &quot;cuisine&quot;, &quot;bricol&quot;, 
&quot;cinema&quot;, &quot;sport&quot;, &quot;heures.tv&quot;)</code></pre>
<p>On obtient en résultat la liste des variables sous forme de vecteur déclaré. On n’a plus alors qu’à copier/coller cette chaîne, rajouter <code>names(d) &lt;-</code> devant et modifier un à un les noms des variables.</p>
<p>Si on souhaite seulement modifier le nom d’une variable, on peut utiliser la fonction <code data-package="questionr">rename.variable</code> de l’extension <strong class="package">questionr</strong>. Celle-ci prend en argument le tableau de données, le nom actuel de la variable et le nouveau nom. Par exemple, si on veut renommer la variable <em>bricol</em> du tableau de données <code>d</code> en <em>bricolage</em> :</p>
<pre class="sourceCode r"><code class="sourceCode r">d &lt;-<span class="st"> </span><span class="kw">rename.variable</span>(d, <span class="st">&quot;bricol&quot;</span>, <span class="st">&quot;bricolage&quot;</span>)
<span class="kw">table</span>(d$bricolage)</code></pre>
<pre><code>
 Non  Oui 
1147  853 </code></pre>
</div>
<div id="facteurs" class="section level3">
<h3>Facteurs</h3>
<p>Parmi les différents types de variables, les facteurs (<em>factor</em>) sont à la fois à part et très utilisés, car ils vont correspondre à la plupart des variables issues d’une question fermée dans un questionnaire.</p>
<p>Les facteurs prennent leurs valeurs dans un ensemble de modalités prédéfinies et ne peuvent en prendre d’autres. La liste des valeurs possibles est donnée par la fonction <code data-package="base">levels</code> :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">levels</span>(d$sexe)</code></pre>
<pre><code>[1] &quot;Homme&quot; &quot;Femme&quot;</code></pre>
<p>Si on veut modifier la valeur du sexe du premier individu de notre tableau de données avec une valeur non autorisée, on obient un message d’erreur et une valeur manquante est utilisée à la place :</p>
<pre class="sourceCode r"><code class="sourceCode r">d$sexe[<span class="dv">1</span>] &lt;-<span class="st"> &quot;Chihuahua&quot;</span></code></pre>
<pre><code>Warning in `[&lt;-.factor`(`*tmp*`, 1, value = structure(c(NA, 2L, 1L, 1L, :
invalid factor level, NA generated</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">d$sexe[<span class="dv">1</span>]</code></pre>
<pre><code>[1] &lt;NA&gt;
Levels: Homme Femme</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">d$sexe[<span class="dv">1</span>] &lt;-<span class="st"> &quot;Homme&quot;</span>
d$sexe[<span class="dv">1</span>]</code></pre>
<pre><code>[1] Homme
Levels: Homme Femme</code></pre>
<p>On peut très facilement créer un facteur à partir d’une variable de type caractères avec la fonction <code data-package="base">factor</code> :</p>
<pre class="sourceCode r"><code class="sourceCode r">v &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="kw">c</span>(<span class="st">&quot;H&quot;</span>, <span class="st">&quot;H&quot;</span>, <span class="st">&quot;F&quot;</span>, <span class="st">&quot;H&quot;</span>))
v</code></pre>
<pre><code>[1] H H F H
Levels: F H</code></pre>
<p>Par défaut, les niveaux d’un facteur nouvellement créés sont l’ensemble des valeurs de la variable caractères, ordonnées par ordre alphabétique. Cette ordre des niveaux est utilisé à chaque fois qu’on utilise des fonctions comme <code data-package="base">table</code>, par exemple :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(v)</code></pre>
<pre><code>v
F H 
1 3 </code></pre>
<p>On peut modifier cet ordre au moment de la création du facteur en utilisant l’option <code>levels</code> :</p>
<pre class="sourceCode r"><code class="sourceCode r">v &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="kw">c</span>(<span class="st">&quot;H&quot;</span>, <span class="st">&quot;H&quot;</span>, <span class="st">&quot;F&quot;</span>, <span class="st">&quot;H&quot;</span>), <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&quot;H&quot;</span>, <span class="st">&quot;F&quot;</span>))
<span class="kw">table</span>(v)</code></pre>
<pre><code>v
H F 
3 1 </code></pre>
<p>On peut aussi modifier l’ordre des niveaux d’une variable déjà existante :</p>
<pre class="sourceCode r"><code class="sourceCode r">d$qualif &lt;-<span class="st"> </span><span class="kw">factor</span>(d$qualif, <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&quot;Ouvrier specialise&quot;</span>, <span class="st">&quot;Ouvrier qualifie&quot;</span>, 
    <span class="st">&quot;Employe&quot;</span>, <span class="st">&quot;Technicien&quot;</span>, <span class="st">&quot;Profession intermediaire&quot;</span>, <span class="st">&quot;Cadre&quot;</span>, <span class="st">&quot;Autre&quot;</span>))
<span class="kw">table</span>(d$qualif)</code></pre>
<pre><code>
      Ouvrier specialise         Ouvrier qualifie                  Employe 
                     203                      292                      594 
              Technicien Profession intermediaire                    Cadre 
                      86                      160                      260 
                   Autre 
                      58 </code></pre>
<div class="astuce">
<p>L’extension <strong class="package">questionr</strong> propose une <em>interface interactive</em> pour le réordonnancement des niveaux d’un facteur. Cette fonction, nommée <code data-package="questionr">iorder</code>, vous permet de réordonner les modalités de manière graphique et de générer le code <strong>R</strong> correspondant.</p>
<p>Dans l’exemple précédant, si vous exécutez :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">iorder</span>(d, <span class="st">&quot;qualif&quot;</span>)</code></pre>
<p><strong>RStudio</strong> devrait ouvrir une fenêtre semblable à celle de la figure ci-dessous.</p>
<p><img src="images/capture_iorder.png" alt="Interface de la commande iorder" /></p>
Vous pouvez alors déplacer les modalités par glisser-déposer, vérifier le résultat dans l’onglet <em>Vérification</em> et, une fois le résultat satisfaisant, récupérer le code généré pour l’inclure dans votre script.
</div>
<p>On peut également modifier les niveaux eux-mêmes. Imaginons que l’on souhaite créer une nouvelle variable <em>qualif.abr</em> contenant les noms abrégés des catégories socioprofessionnelles de <em>qualif</em>. On peut alors procéder comme suit :</p>
<pre class="sourceCode r"><code class="sourceCode r">d$qualif.abr &lt;-<span class="st"> </span><span class="kw">factor</span>(d$qualif, <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&quot;Ouvrier specialise&quot;</span>, <span class="st">&quot;Ouvrier qualifie&quot;</span>, 
    <span class="st">&quot;Employe&quot;</span>, <span class="st">&quot;Technicien&quot;</span>, <span class="st">&quot;Profession intermediaire&quot;</span>, <span class="st">&quot;Cadre&quot;</span>, <span class="st">&quot;Autre&quot;</span>), 
    <span class="dt">labels =</span> <span class="kw">c</span>(<span class="st">&quot;OS&quot;</span>, <span class="st">&quot;OQ&quot;</span>, <span class="st">&quot;Empl&quot;</span>, <span class="st">&quot;Tech&quot;</span>, <span class="st">&quot;Interm&quot;</span>, <span class="st">&quot;Cadre&quot;</span>, <span class="st">&quot;Autre&quot;</span>))
<span class="kw">table</span>(d$qualif.abr)</code></pre>
<pre><code>
    OS     OQ   Empl   Tech Interm  Cadre  Autre 
   203    292    594     86    160    260     58 </code></pre>
<p>Dans ce qui précède, le paramètre <code>levels</code> de <code data-package="base">factor</code> permet de spécifier quels sont les niveaux retenus dans le facteur résultat, ainsi que leur ordre. Le paramètre <code>labels</code>, lui, permet de modifier les noms de ces niveaux dans le facteur résultat. Il est donc capital d’indiquer les noms de <code>labels</code> exactement dans le même ordre que les niveaux de <code>levels</code>. Pour s’assurer de ne pas avoir commis d’erreur, il est recommandé d’effectuer un tableau croisé entre l’ancien et le nouveau facteur :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(d$qualif, d$qualif.abr)</code></pre>
<pre><code>                          
                            OS  OQ Empl Tech Interm Cadre Autre
  Ouvrier specialise       203   0    0    0      0     0     0
  Ouvrier qualifie           0 292    0    0      0     0     0
  Employe                    0   0  594    0      0     0     0
  Technicien                 0   0    0   86      0     0     0
  Profession intermediaire   0   0    0    0    160     0     0
  Cadre                      0   0    0    0      0   260     0
  Autre                      0   0    0    0      0     0    58</code></pre>
<p>On a donc ici un premier moyen d’effectuer un recodage des modalités d’une variable de type facteur. D’autres méthodes existent, voir chapitre (MAJ_LIEN).</p>
<p>À noter que par défaut, les valeurs manquantes ne sont pas considérées comme un niveau de facteur. On peut cependant les transformer en niveau en utilisant la fonction <code data-package="base" data-rdocumentation="factor">addNA</code>. Ceci signifie cependant qu’elle ne seront plus considérées comme manquantes par <strong>R</strong> mais comme une modalité à part entière :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(d$trav.satisf)</code></pre>
<pre><code>  Satisfaction Insatisfaction      Equilibre           NA&#39;s 
           480            117            451            952 </code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(<span class="kw">addNA</span>(d$trav.satisf))</code></pre>
<pre><code>  Satisfaction Insatisfaction      Equilibre           &lt;NA&gt; 
           480            117            451            952 </code></pre>
</div>
</div>
<div id="indexation" class="section level2">
<h2>Indexation</h2>
<p>L’indexation est l’une des fonctionnalités les plus puissantes mais aussi les plus difficiles à maîtriser de <strong>R</strong>. Il s’agit d’opérations permettant de sélectionner des sous-ensembles d’observations et/ou de variables en fonction de différents critères. L’indexation peut porter sur des vecteurs, des matrices ou des tableaux de données.</p>
<p>Le principe est toujours le même : on indique, entre crochets et à la suite du nom de l’objet à indexer, une série de conditions indiquant ce que l’on garde ou non. Ces conditions peuvent être de différents types.</p>
<div id="indexation-directe" class="section level3">
<h3>Indexation directe</h3>
<p>Le mode le plus simple d’indexation consiste à indiquer la position des éléments à conserver. Dans le cas d’un vecteur cela permet de sélectionner un ou plusieurs éléments de ce vecteur.</p>
<p>Soit le vecteur suivant :</p>
<pre class="sourceCode r"><code class="sourceCode r">v &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;d&quot;</span>, <span class="st">&quot;e&quot;</span>, <span class="st">&quot;f&quot;</span>, <span class="st">&quot;g&quot;</span>)</code></pre>
<p>Si on souhaite le premier élément du vecteur, on peut faire :</p>
<pre class="sourceCode r"><code class="sourceCode r">v[<span class="dv">1</span>]</code></pre>
<pre><code>[1] &quot;a&quot;</code></pre>
<p>Si on souhaite les trois premiers éléments ou les éléments 2, 6 et 7 :</p>
<pre class="sourceCode r"><code class="sourceCode r">v[<span class="dv">1</span>:<span class="dv">3</span>]</code></pre>
<pre><code>[1] &quot;a&quot; &quot;b&quot; &quot;c&quot;</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">v[<span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">6</span>, <span class="dv">7</span>)]</code></pre>
<pre><code>[1] &quot;b&quot; &quot;f&quot; &quot;g&quot;</code></pre>
<p>Si on veut le dernier élément :</p>
<pre class="sourceCode r"><code class="sourceCode r">v[<span class="kw">length</span>(v)]</code></pre>
<pre><code>[1] &quot;g&quot;</code></pre>
<p>Dans le cas de matrices ou de tableaux de données, l’indexation prend deux arguments séparés par une virgule : le premier concerne les lignes et le second les colonnes. Ainsi, si on veut l’élément correspondant à la troisième ligne et à la cinquième colonne du tableau de données <code>d</code> :</p>
<pre class="sourceCode r"><code class="sourceCode r">d[<span class="dv">3</span>, <span class="dv">5</span>]</code></pre>
<pre><code>[1] 3994.102</code></pre>
<p>On peut également indiquer des vecteurs :</p>
<pre class="sourceCode r"><code class="sourceCode r">d[<span class="dv">1</span>:<span class="dv">3</span>, <span class="dv">1</span>:<span class="dv">2</span>]</code></pre>
<pre><code>  id age
1  1  28
2  2  23
3  3  59</code></pre>
<p>Si on laisse l’un des deux critères vides, on sélectionne l’intégralité des lignes ou des colonnes. Ainsi si l’on veut seulement la cinquième colonne ou les deux premières lignes :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(d[, <span class="dv">5</span>])</code></pre>
<pre><code> num [1:2000] 2634 9738 3994 5732 4329 ...</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(d[<span class="dv">1</span>:<span class="dv">2</span>, ])</code></pre>
<pre><code>&#39;data.frame&#39;:   2 obs. of  21 variables:
 $ id           : int  1 2
 $ age          : int  28 23
 $ sexe         : Factor w/ 2 levels &quot;Homme&quot;,&quot;Femme&quot;: 1 2
 $ nivetud      : Factor w/ 8 levels &quot;N&#39;a jamais fait d&#39;etudes&quot;,..: 8 NA
 $ poids        : num  2634 9738
 $ occup        : Factor w/ 7 levels &quot;Exerce une profession&quot;,..: 1 3
 $ qualif       : Factor w/ 7 levels &quot;Ouvrier specialise&quot;,..: 3 NA
 $ freres.soeurs: int  8 2
 $ clso         : Factor w/ 3 levels &quot;Oui&quot;,&quot;Non&quot;,&quot;Ne sait pas&quot;: 1 1
 $ relig        : Factor w/ 6 levels &quot;Pratiquant regulier&quot;,..: 4 4
 $ trav.imp     : Factor w/ 4 levels &quot;Le plus important&quot;,..: 4 NA
 $ trav.satisf  : Factor w/ 3 levels &quot;Satisfaction&quot;,..: 2 NA
 $ hard.rock    : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 1
 $ lecture.bd   : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 1
 $ peche.chasse : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 1
 $ cuisine      : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 2 1
 $ bricolage    : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 1
 $ cinema       : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 2
 $ sport        : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 2
 $ heures.tv    : num  0 1
 $ qualif.abr   : Factor w/ 7 levels &quot;OS&quot;,&quot;OQ&quot;,&quot;Empl&quot;,..: 3 NA</code></pre>
<p>Enfin, si on préfixe les arguments avec le signe <kbd>-</kbd>, ceci signifie « tous les éléments sauf ceux indiqués ». Si par exemple on veut tous les éléments de <code>v</code> sauf le premier :</p>
<pre class="sourceCode r"><code class="sourceCode r">v[-<span class="dv">1</span>]</code></pre>
<pre><code>[1] &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot;</code></pre>
<p>Bien sûr, tous ces critères se combinent et on peut stocker le résultat dans un nouvel objet. Dans cet exemple <code>d2</code> contiendra les trois premières lignes de <code>d</code> ainsi que la 50<sup>e</sup> ligne mais sans les colonnes 2 et 5 à 14.</p>
<pre class="sourceCode r"><code class="sourceCode r">d2 &lt;-<span class="st"> </span>d[<span class="kw">c</span>(<span class="dv">1</span>:<span class="dv">3</span>, <span class="dv">50</span>), -<span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">5</span>:<span class="dv">13</span>)]
<span class="kw">str</span>(d2)</code></pre>
<pre><code>&#39;data.frame&#39;:   4 obs. of  11 variables:
 $ id          : int  1 2 3 50
 $ sexe        : Factor w/ 2 levels &quot;Homme&quot;,&quot;Femme&quot;: 1 2 1 2
 $ nivetud     : Factor w/ 8 levels &quot;N&#39;a jamais fait d&#39;etudes&quot;,..: 8 NA 3 8
 $ lecture.bd  : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 1 1 1
 $ peche.chasse: Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 1 1 1
 $ cuisine     : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 2 1 1 1
 $ bricolage   : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 1 1 1
 $ cinema      : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 2 1 1
 $ sport       : Factor w/ 2 levels &quot;Non&quot;,&quot;Oui&quot;: 1 2 2 1
 $ heures.tv   : num  0 1 0 0
 $ qualif.abr  : Factor w/ 7 levels &quot;OS&quot;,&quot;OQ&quot;,&quot;Empl&quot;,..: 3 NA 4 6</code></pre>
</div>
<div id="indexation-par-nom" class="section level3">
<h3>Indexation par nom</h3>
<p>Un autre mode d’indexation consiste à fournir non pas un numéro mais un nom sous forme de chaîne de caractères. On l’utilise couramment pour sélectionner les variables d’un tableau de données. Ainsi, les deux écritures suivantes sont équivalentes<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> :</p>
<pre class="sourceCode r"><code class="sourceCode r">d$clso
d[, <span class="st">&quot;clso&quot;</span>]</code></pre>
<p>Là aussi on peut utiliser un vecteur pour sélectionner plusieurs noms et récupérer un « sous-tableau » de données :</p>
<pre class="sourceCode r"><code class="sourceCode r">d2 &lt;-<span class="st"> </span>d[, <span class="kw">c</span>(<span class="st">&quot;id&quot;</span>, <span class="st">&quot;sexe&quot;</span>, <span class="st">&quot;age&quot;</span>)]</code></pre>
<p>Les noms peuvent également être utilisés pour les observations (lignes) d’un tableau de données si celles-ci ont été munies d’un nom avec la fonction <code data-package="base">row.names</code>. Par défaut les noms de ligne sont leur numéro d’ordre, mais on peut leur assigner comme nom la valeur d’une variable d’identifiant. Ainsi, on peut assigner aux lignes du jeu de données <code>rp99</code> le nom des communes correspondantes :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(rp99)
<span class="kw">row.names</span>(rp99) &lt;-<span class="st"> </span>rp99$nom</code></pre>
<p>On peut alors accéder directement aux communes en donnant leur nom :</p>
<pre class="sourceCode r"><code class="sourceCode r">rp99[<span class="kw">c</span>(<span class="st">&quot;VILLEURBANNE&quot;</span>, <span class="st">&quot;OULLINS&quot;</span>), ]</code></pre>
<p>Par contre il n’est pas possible d’utiliser directement l’opérateur <code>-</code> comme pour l’indexation directe. Pour exclure une colonne en fonction de son nom, on doit uiliser une autre forme d’indexation, l’<em>indexation par condition</em>, expliquée dans la section suivante. On peut ainsi faire…</p>
<pre class="sourceCode r"><code class="sourceCode r">d[, <span class="kw">names</span>(d) !=<span class="st"> &quot;qualif&quot;</span>]</code></pre>
<p>… pour sélectionner toutes les colonnes sauf celle qui s’appelle <em>qualif</em>.</p>
</div>
<div id="indexation-par-condition" class="section level3">
<h3>Indexation par condition</h3>
<div id="tests-et-conditions" class="section level4">
<h4>Tests et conditions</h4>
<p>Une condition est une expression logique dont le résultat est soit <code>TRUE</code> (vrai) soit <code>FALSE</code> (faux).</p>
<p>Une condition comprend la plupart du temps un opérateur de comparaison. Les plus courants sont les suivants :</p>
<table>
<thead>
<tr class="header">
<th align="center">Opérateur</th>
<th align="left">Signification</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><code>==</code></td>
<td align="left">égal à</td>
</tr>
<tr class="even">
<td align="center"><code>!=</code></td>
<td align="left">différent de</td>
</tr>
<tr class="odd">
<td align="center"><code>&gt;</code></td>
<td align="left">strictement supérieur à</td>
</tr>
<tr class="even">
<td align="center"><code>&lt;</code></td>
<td align="left">strictement inférieur à</td>
</tr>
<tr class="odd">
<td align="center"><code>&gt;=</code></td>
<td align="left">supérieur ou égal à</td>
</tr>
<tr class="even">
<td align="center"><code>&lt;=</code></td>
<td align="left">inférieur ou égal à</td>
</tr>
</tbody>
</table>
<p>Voyons tout de suite un exemple :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(d$sexe ==<span class="st"> &quot;Homme&quot;</span>)</code></pre>
<pre><code> logi [1:2000] TRUE FALSE TRUE TRUE FALSE FALSE ...</code></pre>
<p>Que s’est-il passé ? Nous avons fourni à <strong>R</strong> une condition qui signifie « la valeur de la variable <em>sexe</em> vaut “Homme” ». Et il nous a renvoyé un vecteur avec autant d’éléments qu’il y’a d’observations dans <code>d</code>, et dont la valeur est <code>TRUE</code> si l’observation correspond à un homme et <code>FALSE</code> dans les autres cas.</p>
<p>Prenons un autre exemple. On n’affichera cette fois que les premiers éléments de notre variable d’intérêt à l’aide de la fonction <code data-package="utils">head</code> :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(d$age)</code></pre>
<pre><code>[1] 28 23 59 34 71 35</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(d$age &gt;<span class="st"> </span><span class="dv">40</span>)</code></pre>
<pre><code>[1] FALSE FALSE  TRUE FALSE  TRUE FALSE</code></pre>
<p>On voit bien ici qu’à chaque élément du vecteur <code>d$age</code> dont la valeur est supérieure à 40 correspond un élément <code>TRUE</code> dans le résultat de la condition.</p>
<p>On peut combiner ou modifier des conditions à l’aide des opérateurs logiques habituels :</p>
<table>
<thead>
<tr class="header">
<th align="center">Opérateur</th>
<th align="left">Signification</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><code>&amp;</code></td>
<td align="left">et logique</td>
</tr>
<tr class="even">
<td align="center"><code>|</code></td>
<td align="left">ou logique</td>
</tr>
<tr class="odd">
<td align="center"><code>!</code></td>
<td align="left">négation logique</td>
</tr>
</tbody>
</table>
<p>Comment les utilise-t-on ? Voyons tout de suite des exemples. Supposons que je veuille déterminer quels sont dans mon échantillon les hommes ouvriers spécialisés :</p>
<pre class="sourceCode r"><code class="sourceCode r">d$sexe ==<span class="st"> &quot;Homme&quot;</span> &amp;<span class="st"> </span>d$qualif ==<span class="st"> &quot;Ouvrier specialise&quot;</span></code></pre>
<p>Si je souhaite identifier les personnes qui bricolent ou qui font la cuisine :</p>
<pre class="sourceCode r"><code class="sourceCode r">d$bricol ==<span class="st"> &quot;Oui&quot;</span> |<span class="st"> </span>d$cuisine ==<span class="st"> &quot;Oui&quot;</span></code></pre>
<p>Si je souhaite isoler les femmes qui ont entre 20 et 34 ans :</p>
<pre class="sourceCode r"><code class="sourceCode r">d$sexe ==<span class="st"> &quot;Femme&quot;</span> &amp;<span class="st"> </span>d$age &gt;=<span class="st"> </span><span class="dv">20</span> &amp;<span class="st"> </span>d$age &lt;=<span class="st"> </span><span class="dv">34</span></code></pre>
<p>Si je souhaite récupérer les enquêtés qui ne sont pas cadres, on peut utiliser l’une des deux formes suivantes :</p>
<pre class="sourceCode r"><code class="sourceCode r">d$qualif !=<span class="st"> &quot;Cadre&quot;</span>
!(d$qualif ==<span class="st"> &quot;Cadre&quot;</span>)</code></pre>
<p>Lorsqu’on mélange « et » et « ou » il est nécessaire d’utiliser des parenthèses pour différencier les blocs. La condition suivante identifie les femmes qui sont soit cadre, soit employée :</p>
<pre class="sourceCode r"><code class="sourceCode r">d$sexe ==<span class="st"> &quot;Femme&quot;</span> &amp;<span class="st"> </span>(d$qualif ==<span class="st"> &quot;Employe&quot;</span> |<span class="st"> </span>d$qualif ==<span class="st"> &quot;Cadre&quot;</span>)</code></pre>
<p>L’opérateur <code data-package="base" data-rdocumentation="match">%in%</code> peut être très utile : il teste si une valeur fait partie des éléments d’un vecteur. Ainsi on pourrait remplacer la condition précédente par :</p>
<pre class="sourceCode r"><code class="sourceCode r">d$sexe ==<span class="st"> &quot;Femme&quot;</span> &amp;<span class="st"> </span>d$qualif %in%<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Employe&quot;</span>, <span class="st">&quot;Cadre&quot;</span>)</code></pre>
<p>Enfin, signalons qu’on peut utiliser les fonctions <code data-package="base">table</code> ou <code data-package="base">summary</code> pour avoir une idée du résultat de notre condition :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(d$sexe)</code></pre>
<pre><code>
Homme Femme 
  900  1100 </code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(d$sexe ==<span class="st"> &quot;Homme&quot;</span>)</code></pre>
<pre><code>
FALSE  TRUE 
 1100   900 </code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(d$sexe ==<span class="st"> &quot;Homme&quot;</span>)</code></pre>
<pre><code>   Mode   FALSE    TRUE    NA&#39;s 
logical    1100     900       0 </code></pre>
</div>
<div id="utilisation-pour-lindexation" class="section level4">
<h4>Utilisation pour l’indexation</h4>
<p>L’utilisation des conditions pour l’indexation est assez simple : si on indexe un vecteur avec un vecteur booléen, seuls les éléments correspondant à TRUE seront conservés.</p>
<p>Ainsi, si on fait :</p>
<pre class="sourceCode r"><code class="sourceCode r">dh &lt;-<span class="st"> </span>d[d$sexe ==<span class="st"> &quot;Homme&quot;</span>, ]</code></pre>
<p>On obtiendra un nouveau tableau de données comportant l’ensemble des variables de <code>d</code>, mais seulement les observations pour lesquelles la variable <em>sexe</em> vaut « Homme ».</p>
<p>La plupart du temps ce type d’indexation s’applique aux lignes, mais on peut aussi l’utiliser sur les colonnes d’un tableau de données. L’exemple suivant, un peu compliqué, sélectionne uniquement les variables dont le nom commence par <em>a</em> ou <em>s</em> :</p>
<pre class="sourceCode r"><code class="sourceCode r">d2 &lt;-<span class="st"> </span>d[, <span class="kw">substr</span>(<span class="kw">names</span>(d), <span class="dv">0</span>, <span class="dv">1</span>) %in%<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;s&quot;</span>)]</code></pre>
<p>On peut évidemment combiner les différents type d’indexation. L’exemple suivant sélectionne les femmes de plus de 40 ans et ne conserve que les variables <em>qualif</em> et <em>relig</em>.</p>
<pre class="sourceCode r"><code class="sourceCode r">d2 &lt;-<span class="st"> </span>d[d$sexe ==<span class="st"> &quot;Femme&quot;</span> &amp;<span class="st"> </span>d$age &gt;<span class="st"> </span><span class="dv">40</span>, <span class="kw">c</span>(<span class="st">&quot;qualif&quot;</span>, <span class="st">&quot;relig&quot;</span>)]</code></pre>
</div>
<div id="valeurs-manquantes-dans-les-conditions" class="section level4">
<h4>Valeurs manquantes dans les conditions</h4>
<p>Une remarque importante : quand l’un des termes d’une condition comporte une valeur manquante (<code>NA</code>), le résultat de cette condition n’est pas toujours <code>TRUE</code> ou <code>FALSE</code>, il peut aussi être à son tour une valeur manquante.</p>
<pre class="sourceCode r"><code class="sourceCode r">v &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>:<span class="dv">5</span>, <span class="ot">NA</span>)
v</code></pre>
<pre><code>[1]  1  2  3  4  5 NA</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">v &gt;<span class="st"> </span><span class="dv">3</span></code></pre>
<pre><code>[1] FALSE FALSE FALSE  TRUE  TRUE    NA</code></pre>
<p>On voit que le test <code>NA &gt; 3</code> ne renvoie ni vrai ni faux, mais <code>NA</code>.</p>
<p>Le résultat d’une condition peut donc comporter un grand nombre de valeurs manquantes :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(d$trav.satisf ==<span class="st"> &quot;Satisfaction&quot;</span>)</code></pre>
<pre><code>   Mode   FALSE    TRUE    NA&#39;s 
logical     568     480     952 </code></pre>
<p>Une autre conséquence importante de ce comportement est qu’on ne peut pas utiliser l’opérateur l’expression <code>== NA</code> pour tester la présence de valeurs manquantes. On utilisera à la place la fonction <em>ad hoc</em> <code data-package="base" data-rdocumentation="NA">is.na</code>.</p>
<p>On comprendra mieux le problème avec l’exemple suivant :</p>
<pre class="sourceCode r"><code class="sourceCode r">v &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="ot">NA</span>)
v</code></pre>
<pre><code>[1]  1 NA</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">v ==<span class="st"> </span><span class="ot">NA</span></code></pre>
<pre><code>[1] NA NA</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">is.na</span>(v)</code></pre>
<pre><code>[1] FALSE  TRUE</code></pre>
<p>Pour compliquer encore un peu le tout, lorsqu’on utilise une condition pour l’indexation, si la condition renvoie <code>NA</code>, <strong>R</strong> ne sélectionne pas l’élément mais retourne quand même la valeur <code>NA</code>. Ceci aura donc des conséquences pour l’extraction de sous-populations (voir section ci-après MAJ LIEN)<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>.</p>
</div>
</div>
<div id="indexation-et-assignation" class="section level3">
<h3>Indexation et assignation</h3>
<p>Dans tous les exemples précédents, on a utilisé l’indexation pour extraire une partie d’un vecteur ou d’un tableau de données, en plaçant l’opération d’indexation à droite de l’opérateur <code>&lt;-</code>.</p>
<p>Mais l’indexation peut également être placée à gauche de cet opérateur. Dans ce cas, les éléments sélectionnés par l’indexation sont alors remplacés par les valeurs indiquées à droite de l’opérateur <code>&lt;-</code>.</p>
<p>Prenons donc un exemple simple :</p>
<pre class="sourceCode r"><code class="sourceCode r">v &lt;-<span class="st"> </span><span class="dv">1</span>:<span class="dv">5</span>
v</code></pre>
<pre><code>[1] 1 2 3 4 5</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">v[<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="dv">3</span>
v</code></pre>
<pre><code>[1] 3 2 3 4 5</code></pre>
<p>Cette fois, au lieu d’utiliser quelque chose comme <code>x &lt;- v[1]</code>, qui aurait placé la valeur du premier élément de <code>v</code> dans <code>x</code>, on a utilisé <code>v[1] &lt;- 3</code>, ce qui a mis à jour le premier élément de <code>v</code> avec la valeur 3. Ceci fonctionne également pour les tableaux de données et pour les différents types d’indexation évoqués précédemment :</p>
<pre class="sourceCode r"><code class="sourceCode r">d[<span class="dv">257</span>, <span class="st">&quot;sexe&quot;</span>] &lt;-<span class="st"> &quot;Homme&quot;</span></code></pre>
<p>Enfin on peut modifier plusieurs éléments d’un seul coup soit en fournissant un vecteur, soit en profitant du mécanisme de recyclage. Les deux commandes suivantes sont ainsi rigoureusement équivalentes :</p>
<pre class="sourceCode r"><code class="sourceCode r">d[<span class="kw">c</span>(<span class="dv">257</span>, <span class="dv">438</span>, <span class="dv">889</span>), <span class="st">&quot;sexe&quot;</span>] &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Homme&quot;</span>, <span class="st">&quot;Homme&quot;</span>, <span class="st">&quot;Homme&quot;</span>)
d[<span class="kw">c</span>(<span class="dv">257</span>, <span class="dv">438</span>, <span class="dv">889</span>), <span class="st">&quot;sexe&quot;</span>] &lt;-<span class="st"> &quot;Homme&quot;</span></code></pre>
<p>On commence à voir comment l’utilisation de l’indexation par conditions et de l’assignation va nous permettre de faire des recodages.</p>
<pre class="sourceCode r"><code class="sourceCode r">d$gr.age[d$age &gt;=<span class="st"> </span><span class="dv">20</span> &amp;<span class="st"> </span>d$age &lt;=<span class="st"> </span><span class="dv">30</span>] &lt;-<span class="st"> &quot;20-30 ans&quot;</span>
d$gr.age[<span class="kw">is.na</span>(d$age)] &lt;-<span class="st"> &quot;Inconnu&quot;</span></code></pre>
</div>
</div>
<div id="sous-populations" class="section level2">
<h2>Sous-populations</h2>
<div id="par-indexation" class="section level3">
<h3>Par indexation</h3>
<p>La première manière de construire des sous-populations est d’utiliser l’indexation par conditions. On peut ainsi facilement sélectionner une partie des observations suivant un ou plusieurs critères et placer le résultat dans un nouveau tableau de données.</p>
<p>Par exemple si on souhaite isoler les hommes et les femmes :</p>
<pre class="sourceCode r"><code class="sourceCode r">dh &lt;-<span class="st"> </span>d[d$sexe ==<span class="st"> &quot;Homme&quot;</span>, ]
df &lt;-<span class="st"> </span>d[d$sexe ==<span class="st"> &quot;Femme&quot;</span>, ]
<span class="kw">table</span>(d$sexe)</code></pre>
<pre><code>
Homme Femme 
  901  1099 </code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">dim</span>(dh)</code></pre>
<pre><code>[1] 901  22</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">dim</span>(df)</code></pre>
<pre><code>[1] 1099   22</code></pre>
<p>On a à partir de là trois tableaux de données, <code>d</code> comportant la population totale, <code>dh</code> seulement les hommes et <code>df</code> seulement les femmes.</p>
<p>On peut évidemment combiner plusieurs critères :</p>
<pre class="sourceCode r"><code class="sourceCode r">dh<span class="fl">.25</span> &lt;-<span class="st"> </span>d[d$sexe ==<span class="st"> &quot;Homme&quot;</span> &amp;<span class="st"> </span>d$age &lt;=<span class="st"> </span><span class="dv">25</span>, ]
<span class="kw">dim</span>(dh<span class="fl">.25</span>)</code></pre>
<pre><code>[1] 87 22</code></pre>
<p>Si on utilise directement l’indexation, il convient cependant d’être extrêmement prudent avec les valeurs manquantes. Comme indiqué précédemment, la présence d’une valeur manquante dans une condition fait que celle-ci est évaluée en <code>NA</code> et qu’au final la ligne correspondante est conservée par l’indexation :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(d$trav.satisf)</code></pre>
<pre><code>  Satisfaction Insatisfaction      Equilibre           NA&#39;s 
           480            117            451            952 </code></pre>
<pre class="sourceCode r"><code class="sourceCode r">d.satisf &lt;-<span class="st"> </span>d[d$trav.satisf ==<span class="st"> &quot;Satisfaction&quot;</span>, ]
<span class="kw">dim</span>(d.satisf)</code></pre>
<pre><code>[1] 1432   22</code></pre>
<p>Comme on le voit, ici <code>d.satisf</code> contient les individus ayant la modalité <em>Satisfaction</em> mais aussi ceux ayant une valeur manquante <code>NA</code>. C’est pourquoi il faut toujours soit vérifier au préalable qu’on n’a pas de valeurs manquantes dans les variables de la condition, soit exclure explicitement les <code>NA</code> de la manière suivante :</p>
<pre class="sourceCode r"><code class="sourceCode r">d.satisf &lt;-<span class="st"> </span>d[d$trav.satisf ==<span class="st"> &quot;Satisfaction&quot;</span> &amp;<span class="st"> </span>!<span class="kw">is.na</span>(d$trav.satisf), ]
<span class="kw">dim</span>(d.satisf)</code></pre>
<pre><code>[1] 480  22</code></pre>
<p>C’est notamment pour cette raison qu’on préfèrera le plus souvent utiliser la fonction <code data-package="base">subset</code>.</p>
</div>
<div id="subset" class="section level3">
<h3>Fonction subset</h3>
<p>La fonction <code data-package="base">subset</code> permet d’extraire des sous-populations de manière plus simple et un peu plus intuitive que l’indexation directe.</p>
<p>Celle-ci prend trois arguments principaux : * le nom de l’objet de départ ; * une condition sur les observations (<code>subset</code>) ; * éventuellement une condition sur les colonnes (<code>select</code>).</p>
<p>Reprenons tout de suite un exemple déjà vu :</p>
<pre class="sourceCode r"><code class="sourceCode r">dh &lt;-<span class="st"> </span><span class="kw">subset</span>(d, sexe ==<span class="st"> &quot;Homme&quot;</span>)
df &lt;-<span class="st"> </span><span class="kw">subset</span>(d, sexe ==<span class="st"> &quot;Femme&quot;</span>)</code></pre>
<p>L’utilisation de <code data-package="base">subset</code> présente plusieurs avantages. Le premier est d’économiser quelques touches. On n’est en effet pas obligé de saisir le nom du tableau de données dans la condition sur les lignes. Ainsi les deux commandes suivantes sont équivalentes :</p>
<pre class="sourceCode r"><code class="sourceCode r">dh &lt;-<span class="st"> </span><span class="kw">subset</span>(d, d$sexe ==<span class="st"> &quot;Homme&quot;</span>)
dh &lt;-<span class="st"> </span><span class="kw">subset</span>(d, sexe ==<span class="st"> &quot;Homme&quot;</span>)</code></pre>
<p>Le second avantage est que <code data-package="base">subset</code> s’occupe du problème des valeurs manquantes évoquées précédemment et les exclut de lui-même, contrairement au comportement par défaut :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(d$trav.satisf)</code></pre>
<pre><code>  Satisfaction Insatisfaction      Equilibre           NA&#39;s 
           480            117            451            952 </code></pre>
<pre class="sourceCode r"><code class="sourceCode r">d.satisf &lt;-<span class="st"> </span>d[d$trav.satisf ==<span class="st"> &quot;Satisfaction&quot;</span>, ]
<span class="kw">dim</span>(d.satisf)</code></pre>
<pre><code>[1] 1432   22</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">d.satisf &lt;-<span class="st"> </span><span class="kw">subset</span>(d, trav.satisf ==<span class="st"> &quot;Satisfaction&quot;</span>)
<span class="kw">dim</span>(d.satisf)</code></pre>
<pre><code>[1] 480  22</code></pre>
<p>Enfin, l’utilisation de l’argument <code>select</code> est simplifié pour l’expression de condition sur les colonnes. On peut ainsi spécifier les noms de variable sans guillemets et leur appliquer directement l’opérateur d’exclusion <code>-</code> :</p>
<pre class="sourceCode r"><code class="sourceCode r">d2 &lt;-<span class="st"> </span><span class="kw">subset</span>(d, <span class="dt">select =</span> <span class="kw">c</span>(sexe, sport))
d2 &lt;-<span class="st"> </span><span class="kw">subset</span>(d, age &gt;<span class="st"> </span><span class="dv">25</span>, <span class="dt">select =</span> -<span class="kw">c</span>(id, age, cinema))</code></pre>
</div>
<div id="tapply" class="section level3">
<h3>Fonction tapply</h3>
<div class="note">
Cette section documente une fonction qui peut être très utile, mais pas forcément indispensable au départ.
</div>
<p>La fonction <code data-package="base">tapply</code> n’est qu’indirectement liée à la notion de sous-population, mais peut permettre d’éviter d’avoir à créer ces sous-populations dans certains cas.</p>
<p>Son fonctionnement est assez simple, mais pas forcément intuitif. La fonction prend trois arguments : un vecteur, un facteur et une fonction. Elle applique ensuite la fonction aux éléments du vecteur correspondant à un même niveau du facteur. Vite, un exemple !</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tapply</span>(d$age, d$sexe, mean)</code></pre>
<pre><code>   Homme    Femme 
48.10655 48.19836 </code></pre>
<p>Qu’est-ce que ça signifie ? Ici <code data-package="base">tapply</code> a sélectionné toutes les observations correspondant à « Homme », puis appliqué la fonction <code data-package="base">mean</code> aux valeurs de <em>age</em> correspondantes. Puis elle a fait de même pour les observations correspondant à « Femme ». On a donc ici la moyenne d’âge chez les hommes et chez les femmes.</p>
<p>On peut fournir à peu près n’importe quelle fonction à <code data-package="base">tapply</code> :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tapply</span>(d$bricol, d$sexe, freq)</code></pre>
<pre><code>$Homme
      n    % val%
Non 386 42.8 42.8
Oui 515 57.2 57.2
NA    0  0.0   NA

$Femme
      n    % val%
Non 761 69.2 69.2
Oui 338 30.8 30.8
NA    0  0.0   NA</code></pre>
<p>Les arguments supplémentaires fournis à <code data-package="base">tapply</code> sont en fait fournis directement à la fonction appelée.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tapply</span>(d$bricol, d$sexe, freq, <span class="dt">total =</span> <span class="ot">TRUE</span>)</code></pre>
<pre><code>$Homme
        n     %  val%
Non   386  42.8  42.8
Oui   515  57.2  57.2
NA      0   0.0    NA
Total 901 100.0 100.0

$Femme
         n     %  val%
Non    761  69.2  69.2
Oui    338  30.8  30.8
NA       0   0.0    NA
Total 1099 100.0 100.0</code></pre>
<div class="note">
<p>La fonction <code data-package="base">by</code> est un équivalent (pour les tableaux de données) de <code data-package="base">tapply</code>. La présentation des résultats diffère légèrement.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tapply</span>(d$age, d$sexe, mean)</code></pre>
<pre><code>   Homme    Femme 
48.10655 48.19836 </code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">by</span>(d$age, d$sexe, mean)</code></pre>
<pre><code>d$sexe: Homme
[1] 48.10655
-------------------------------------------------------- 
d$sexe: Femme
[1] 48.19836</code></pre>
</div>
</div>
</div>
<div id="recodages" class="section level2">
<h2>Recodages</h2>
<p>Le recodage de variables est une opération extrêmement fréquente lors du traitement d’enquête. Celuici utilise soit l’une des formes d’indexation décrites précédemment, soit des fonctions <em>ad hoc</em> de <strong>R</strong>.</p>
<p>On passe ici en revue différents types de recodage parmi les plus courants. Les exemples s’appuient, comme précédemment, sur l’extrait de l’enquête <em>Histoire de vie</em> :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(hdv2003)
d &lt;-<span class="st"> </span>hdv2003</code></pre>
<div id="convertir-une-variable" class="section level3">
<h3>Convertir une variable</h3>
<p>Il peut arriver qu’on veuille transformer une variable d’un type dans un autre.</p>
<p>Par exemple, on peut considérer que la variable numérique <em>freres.soeurs</em> est une « fausse » variable numérique et qu’une représentation sous forme de facteur serait plus adéquate. Dans ce cas il suffit de faire appel à la fonction <code data-package="base">factor</code> :</p>
<pre class="sourceCode r"><code class="sourceCode r">d$fs.fac &lt;-<span class="st"> </span><span class="kw">factor</span>(d$freres.soeurs)
<span class="kw">levels</span>(d$fs.fac)</code></pre>
<pre><code> [1] &quot;0&quot;  &quot;1&quot;  &quot;2&quot;  &quot;3&quot;  &quot;4&quot;  &quot;5&quot;  &quot;6&quot;  &quot;7&quot;  &quot;8&quot;  &quot;9&quot;  &quot;10&quot; &quot;11&quot; &quot;12&quot; &quot;13&quot;
[15] &quot;14&quot; &quot;15&quot; &quot;16&quot; &quot;18&quot; &quot;22&quot;</code></pre>
<p>La conversion d’une variable caractères en facteur se fait de la même manière.</p>
<p>La conversion d’un facteur ou d’une variable numérique en variable caractères peut se faire à l’aide de la fonction <code data-package="base" data-rdocumentation="character">as.character</code> :</p>
<pre class="sourceCode r"><code class="sourceCode r">d$fs.char &lt;-<span class="st"> </span><span class="kw">as.character</span>(d$freres.soeurs)
d$qualif.char &lt;-<span class="st"> </span><span class="kw">as.character</span>(d$qualif)</code></pre>
<p>La conversion d’un facteur en caractères est fréquemment utilisé lors des recodages du fait qu’il est impossible d’ajouter de nouvelles modalités à un facteur de cette manière. Par exemple, la première des commandes suivantes génère un message d’avertissement, tandis que les deux autres fonctionnent :</p>
<pre class="sourceCode r"><code class="sourceCode r">d.temp &lt;-<span class="st"> </span>d
d.temp$qualif[d.temp$qualif ==<span class="st"> &quot;Ouvrier specialise&quot;</span>] &lt;-<span class="st"> &quot;Ouvrier&quot;</span></code></pre>
<pre><code>Warning in `[&lt;-.factor`(`*tmp*`, d.temp$qualif == &quot;Ouvrier specialise&quot;, :
invalid factor level, NA generated</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">d$qualif.char &lt;-<span class="st"> </span><span class="kw">as.character</span>(d$qualif)
d$qualif.char[d$qualif.char ==<span class="st"> &quot;Ouvrier specialise&quot;</span>] &lt;-<span class="st"> &quot;Ouvrier&quot;</span></code></pre>
<p>Dans le premier cas, le message d’avertissement indique que toutes les modalités « Ouvrier specialise » de notre variable <em>qualif</em> ont été remplacées par des valeurs manquantes <code>NA</code>.</p>
<p>Enfin, une variable de type caractères dont les valeurs seraient des nombres peut être convertie en variable numérique avec la fonction <code data-package="base" data-rdocumentation="numeric">as.numeric</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">v &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;1&quot;</span>, <span class="st">&quot;3.1415&quot;</span>, <span class="st">&quot;4&quot;</span>, <span class="st">&quot;5.6&quot;</span>, <span class="st">&quot;1&quot;</span>, <span class="st">&quot;4&quot;</span>)
v</code></pre>
<pre><code>[1] &quot;1&quot;      &quot;3.1415&quot; &quot;4&quot;      &quot;5.6&quot;    &quot;1&quot;      &quot;4&quot;     </code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as.numeric</span>(v)</code></pre>
<pre><code>[1] 1.0000 3.1415 4.0000 5.6000 1.0000 4.0000</code></pre>
<div class="attention">
<p>Lorsque l’on convertit un facteur avec <code data-package="base" data-rdocumentation="numeric">as.numeric</code>, on obtient le numéro de chaque facteur (première modalité, seconde modalité, etc.). Si la valeur numérique qui nous intéresse est en fait contenu dans le nom des modalités, il faut connvertir au préalable notre facteur en variable textuelle.</p>
<pre class="sourceCode r"><code class="sourceCode r">vf &lt;-<span class="st"> </span><span class="kw">factor</span>(v)
vf</code></pre>
<pre><code>[1] 1      3.1415 4      5.6    1      4     
Levels: 1 3.1415 4 5.6</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as.numeric</span>(vf)</code></pre>
<pre><code>[1] 1 2 3 4 1 3</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as.numeric</span>(<span class="kw">as.character</span>(vf))</code></pre>
<pre><code>[1] 1.0000 3.1415 4.0000 5.6000 1.0000 4.0000</code></pre>
</div>
</div>
<div id="decouper-une-variable-numerique-en-classes" class="section level3">
<h3>Découper une variable numérique en classes</h3>
<p>Le premier type de recodage consiste à découper une variable de type numérique en un certain nombre de classes. On utilise pour cela la fonction <code data-package="base">cut</code>.</p>
<p>Celle-ci prend, outre la variable à découper, un certain nombre d’arguments :</p>
<ul>
<li><code>breaks</code> indique soit le nombre de classes souhaité, soit, si on lui fournit un vecteur, les limites des classes ;</li>
<li><code>labels</code> permet de modifier les noms de modalités attribués aux classes ;</li>
<li><code>include.lowest</code> et <code>right</code> influent sur la manière dont les valeurs situées à la frontière des classes seront inclues ou exclues ;</li>
<li><code>dig.lab</code> indique le nombre de chiffres après la virgule à conserver dans les noms de modalités.</li>
</ul>
<p>Prenons tout de suite un exemple et tentons de découper notre variable <em>age</em> en cinq classes et de placer le résultat dans une nouvelle variable nommée <em>age5cl</em> :</p>
<pre class="sourceCode r"><code class="sourceCode r">d$age5cl &lt;-<span class="st"> </span><span class="kw">cut</span>(d$age, <span class="dv">5</span>)
<span class="kw">table</span>(d$age5cl)</code></pre>
<pre><code>
(17.9,33.8] (33.8,49.6] (49.6,65.4] (65.4,81.2] (81.2,97.1] 
        454         628         556         319          43 </code></pre>
<p>Par défaut <strong>R</strong> nous a bien créé cinq classes d’amplitudes égales. La première classe va de 16,9 à 32,2 ans (en fait de 17 à 32), etc.</p>
<p>Les frontières de classe seraient plus présentables si elles utilisaient des nombres ronds. On va donc spécifier manuellement le découpage souhaité, par tranches de 20 ans :</p>
<pre class="sourceCode r"><code class="sourceCode r">d$age20 &lt;-<span class="st"> </span><span class="kw">cut</span>(d$age, <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">20</span>, <span class="dv">40</span>, <span class="dv">60</span>, <span class="dv">80</span>, <span class="dv">100</span>))
<span class="kw">table</span>(d$age20)</code></pre>
<pre><code>
  (0,20]  (20,40]  (40,60]  (60,80] (80,100] 
      72      660      780      436       52 </code></pre>
<p>On aurait pu tenir compte des âges extrêmes pour la première et la dernière valeur :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">range</span>(d$age)</code></pre>
<pre><code>[1] 18 97</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">d$age20 &lt;-<span class="st"> </span><span class="kw">cut</span>(d$age, <span class="kw">c</span>(<span class="dv">17</span>, <span class="dv">20</span>, <span class="dv">40</span>, <span class="dv">60</span>, <span class="dv">80</span>, <span class="dv">93</span>))
<span class="kw">table</span>(d$age20)</code></pre>
<pre><code>
(17,20] (20,40] (40,60] (60,80] (80,93] 
     72     660     780     436      50 </code></pre>
<p>Les symboles dans les noms attribués aux classes ont leur importance : <code>(</code> signifie que la frontière de la classe est exclue, tandis que <code>[</code> signifie qu’elle est incluse. Ainsi, <code>(20,40]</code> signifie « strictement supérieur à 20 et inférieur ou égal à 40 ».</p>
<p>On remarque que du coup, dans notre exemple précédent, la valeur minimale, 17, est exclue de notre première classe, et qu’une observation est donc absente de ce découpage. Pour résoudre ce problème on peut soit faire commencer la première classe à 16, soit utiliser l’option <code>include.lowest=TRUE</code> :</p>
<pre class="sourceCode r"><code class="sourceCode r">d$age20 &lt;-<span class="st"> </span><span class="kw">cut</span>(d$age, <span class="kw">c</span>(<span class="dv">16</span>, <span class="dv">20</span>, <span class="dv">40</span>, <span class="dv">60</span>, <span class="dv">80</span>, <span class="dv">93</span>))
<span class="kw">table</span>(d$age20)</code></pre>
<pre><code>
(16,20] (20,40] (40,60] (60,80] (80,93] 
     72     660     780     436      50 </code></pre>
<pre class="sourceCode r"><code class="sourceCode r">d$age20 &lt;-<span class="st"> </span><span class="kw">cut</span>(d$age, <span class="kw">c</span>(<span class="dv">17</span>, <span class="dv">20</span>, <span class="dv">40</span>, <span class="dv">60</span>, <span class="dv">80</span>, <span class="dv">93</span>), <span class="dt">include.lowest =</span> <span class="ot">TRUE</span>)
<span class="kw">table</span>(d$age20)</code></pre>
<pre><code>
[17,20] (20,40] (40,60] (60,80] (80,93] 
     72     660     780     436      50 </code></pre>
<p>On peut également modifier le sens des intervalles avec l’option <code>right=FALSE</code>, et indiquer manuellement les noms des modalités avec <code>labels</code> :</p>
<pre class="sourceCode r"><code class="sourceCode r">d$age20 &lt;-<span class="st"> </span><span class="kw">cut</span>(d$age, <span class="kw">c</span>(<span class="dv">16</span>, <span class="dv">20</span>, <span class="dv">40</span>, <span class="dv">60</span>, <span class="dv">80</span>, <span class="dv">93</span>), <span class="dt">right =</span> <span class="ot">FALSE</span>, <span class="dt">include.lowest =</span> <span class="ot">TRUE</span>)
<span class="kw">table</span>(d$age20)</code></pre>
<pre><code>
[16,20) [20,40) [40,60) [60,80) [80,93] 
     48     643     793     454      60 </code></pre>
<pre class="sourceCode r"><code class="sourceCode r">d$age20 &lt;-<span class="st"> </span><span class="kw">cut</span>(d$age, <span class="kw">c</span>(<span class="dv">17</span>, <span class="dv">20</span>, <span class="dv">40</span>, <span class="dv">60</span>, <span class="dv">80</span>, <span class="dv">93</span>), <span class="dt">include.lowest =</span> <span class="ot">TRUE</span>, <span class="dt">labels =</span> <span class="kw">c</span>(<span class="st">&quot;&lt;20ans&quot;</span>, 
    <span class="st">&quot;21-40 ans&quot;</span>, <span class="st">&quot;41-60ans&quot;</span>, <span class="st">&quot;61-80ans&quot;</span>, <span class="st">&quot;&gt;80ans&quot;</span>))
<span class="kw">table</span>(d$age20)</code></pre>
<pre><code>
   &lt;20ans 21-40 ans  41-60ans  61-80ans    &gt;80ans 
       72       660       780       436        50 </code></pre>
<div class="astuce">
<p>L’extension <strong class="package">questionr</strong> propose une interface interactive à la fonction <code data-package="base">cut</code>, nommée <code data-package="questionr">icut</code>. Elle s’utilise de la manière suivante :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">icut</span>(d, age)</code></pre>
<p><strong>RStudio</strong> devrait ouvrir une fenêtre semblable à l’image ci-dessous.</p>
<p><img src="images/capture_icut.png" alt="Capture d’écran d’icut" /></p>
<p>Vous pouvez alors indiquer les limites de vos classes ainsi que quelques options complémentaires. Ces limites sont représentées graphiquement sur l’histogramme de la variable d’origine.</p>
<p>L’onglet <em>Vérification</em> affiche un tri à plat et un graphique en barres de la nouvelle variable. Une fois le résultat satisfaisant, vous pouvez récupérer le code généré pour l’inclure dans votre script.</p>
<p>L’extension <strong class="package">questionr</strong> propose aussi une fonction <code data-package="questionr">quant.cut</code> permettant de découper une variable numérique en un nombre de classes donné ayant des efffectifs semblables. Il suffit de lui passer le nombre de classes en argument :</p>
<pre class="sourceCode r"><code class="sourceCode r">d$age6cl &lt;-<span class="st"> </span><span class="kw">quant.cut</span>(d$age, <span class="dv">6</span>)
<span class="kw">table</span>(d$age6cl)</code></pre>
<pre><code>
    [18,30)     [30,39)     [39,48) [48,55.667) [55.667,66)     [66,97] 
        302         337         350         344         305         362 </code></pre>
<code data-package="questionr">quant.cut</code> admet les mêmes autres options que <code data-package="base">cut</code> (<code>include.lowest</code>, <code>right</code>, <code>labels</code>. . . ).
</div>
</div>
<div id="regrouper-les-modalites-dune-variable" class="section level3">
<h3>Regrouper les modalités d’une variable</h3>
<p>Pour regrouper les modalités d’une variable qualitative (d’un facteur le plus souvent), on peut utiliser directement l’indexation.</p>
<p>Ainsi, si on veut recoder la variable qualif dans une variable qualif.reg plus « compacte », on peut utiliser :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(d$qualif)</code></pre>
<pre><code>
      Ouvrier specialise         Ouvrier qualifie               Technicien 
                     203                      292                       86 
Profession intermediaire                    Cadre                  Employe 
                     160                      260                      594 
                   Autre 
                      58 </code></pre>
<pre class="sourceCode r"><code class="sourceCode r">d$qualif.reg[d$qualif ==<span class="st"> &quot;Ouvrier specialise&quot;</span>] &lt;-<span class="st"> &quot;Ouvrier&quot;</span>
d$qualif.reg[d$qualif ==<span class="st"> &quot;Ouvrier qualifie&quot;</span>] &lt;-<span class="st"> &quot;Ouvrier&quot;</span>
d$qualif.reg[d$qualif ==<span class="st"> &quot;Employe&quot;</span>] &lt;-<span class="st"> &quot;Employe&quot;</span>
d$qualif.reg[d$qualif ==<span class="st"> &quot;Profession intermediaire&quot;</span>] &lt;-<span class="st"> &quot;Intermediaire&quot;</span>
d$qualif.reg[d$qualif ==<span class="st"> &quot;Technicien&quot;</span>] &lt;-<span class="st"> &quot;Intermediaire&quot;</span>
d$qualif.reg[d$qualif ==<span class="st"> &quot;Cadre&quot;</span>] &lt;-<span class="st"> &quot;Cadre&quot;</span>
d$qualif.reg[d$qualif ==<span class="st"> &quot;Autre&quot;</span>] &lt;-<span class="st"> &quot;Autre&quot;</span>
<span class="kw">table</span>(d$qualif.reg)</code></pre>
<pre><code>
        Autre         Cadre       Employe Intermediaire       Ouvrier 
           58           260           594           246           495 </code></pre>
<p>On aurait pu représenter ce recodage de manière plus compacte, notamment en commençant par copier le contenu de <em>qualif</em> dans <em>qualif.reg</em>, ce qui permet de ne pas s’occuper de ce qui ne change pas.</p>
<p>Il est cependant nécessaire de ne pas copier <em>qualif</em> sous forme de facteur, sinon on ne pourrait ajouter de nouvelles modalités. On copie donc la version caractères de qualif grâce à la fonction <code data-package="base" data-rdocumentation="character">as.character</code> :</p>
<pre class="sourceCode r"><code class="sourceCode r">d$qualif.reg &lt;-<span class="st"> </span><span class="kw">as.character</span>(d$qualif)
d$qualif.reg[d$qualif ==<span class="st"> &quot;Ouvrier specialise&quot;</span>] &lt;-<span class="st"> &quot;Ouvrier&quot;</span>
d$qualif.reg[d$qualif ==<span class="st"> &quot;Ouvrier qualifie&quot;</span>] &lt;-<span class="st"> &quot;Ouvrier&quot;</span>
d$qualif.reg[d$qualif ==<span class="st"> &quot;Profession intermediaire&quot;</span>] &lt;-<span class="st"> &quot;Intermediaire&quot;</span>
d$qualif.reg[d$qualif ==<span class="st"> &quot;Technicien&quot;</span>] &lt;-<span class="st"> &quot;Intermediaire&quot;</span>
<span class="kw">table</span>(d$qualif.reg)</code></pre>
<pre><code>
        Autre         Cadre       Employe Intermediaire       Ouvrier 
           58           260           594           246           495 </code></pre>
<p>On peut faire une version encore plus compacte en utilisant l’opérateur logique <em>ou</em> (<code>|</code>) :</p>
<pre class="sourceCode r"><code class="sourceCode r">d$qualif.reg &lt;-<span class="st"> </span><span class="kw">as.character</span>(d$qualif)
d$qualif.reg[d$qualif ==<span class="st"> &quot;Ouvrier specialise&quot;</span> |<span class="st"> </span>d$qualif ==<span class="st"> &quot;Ouvrier qualifie&quot;</span>] &lt;-<span class="st"> &quot;Ouvrier&quot;</span>
d$qualif.reg[d$qualif ==<span class="st"> &quot;Profession intermediaire&quot;</span> |<span class="st"> </span>d$qualif ==<span class="st"> &quot;Technicien&quot;</span>] &lt;-<span class="st"> &quot;Intermediaire&quot;</span>
<span class="kw">table</span>(d$qualif.reg)</code></pre>
<pre><code>
        Autre         Cadre       Employe Intermediaire       Ouvrier 
           58           260           594           246           495 </code></pre>
<p>Enfin, pour terminer ce petit tour d’horizon, on peut également remplacer l’opérateur <code>|</code> par <code>%in%</code>, qui peut parfois être plus lisible :</p>
<pre class="sourceCode r"><code class="sourceCode r">d$qualif.reg &lt;-<span class="st"> </span><span class="kw">as.character</span>(d$qualif)
d$qualif.reg[d$qualif %in%<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Ouvrier specialise&quot;</span>, <span class="st">&quot;Ouvrier qualifie&quot;</span>)] &lt;-<span class="st"> &quot;Ouvrier&quot;</span>
d$qualif.reg[d$qualif %in%<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Profession intermediaire&quot;</span>, <span class="st">&quot;Technicien&quot;</span>)] &lt;-<span class="st"> &quot;Intermediaire&quot;</span>
<span class="kw">table</span>(d$qualif.reg)</code></pre>
<pre><code>
        Autre         Cadre       Employe Intermediaire       Ouvrier 
           58           260           594           246           495 </code></pre>
<p>Dans tous les cas le résultat obtenu est une variable de type caractère. On pourra la convertir en facteur par un simple :</p>
<pre class="sourceCode r"><code class="sourceCode r">d$qualif.reg &lt;-<span class="st"> </span><span class="kw">factor</span>(d$qualif.reg)</code></pre>
<p>Si on souhaite recoder les valeurs manquantes, il suffit de faire appel à la fonction <code data-package="base" data-rdocumentation="NA">is.na</code> :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(d$trav.satisf)</code></pre>
<pre><code>
  Satisfaction Insatisfaction      Equilibre 
           480            117            451 </code></pre>
<pre class="sourceCode r"><code class="sourceCode r">d$trav.satisf.reg &lt;-<span class="st"> </span><span class="kw">as.character</span>(d$trav.satisf)
d$trav.satisf.reg[<span class="kw">is.na</span>(d$trav.satisf)] &lt;-<span class="st"> &quot;Manquant&quot;</span>
<span class="kw">table</span>(d$trav.satisf.reg)</code></pre>
<pre><code>
     Equilibre Insatisfaction       Manquant   Satisfaction 
           451            117            952            480 </code></pre>
<div class="astuce">
<p><strong class="package">questionr</strong> propose une interface interactive pour le recodage d’une variable qualitative (renommage et regroupement de modalités). Cette fonction, nommée <code data-package="questionr">irec</code>, s’utilise de la manière suivante :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">irec</span>(d, qualif)</code></pre>
<p><strong>RStudio</strong> va alors ouvrir une fenêtre semblable à l’image ci-dessous :</p>
<p><img src="images/capture_irec.png" alt="Capture de irec" /></p>
<p>Vous pouvez alors sélectionner différentes options, et pour chaque ancienne modalité, indiquer la nouvelle valeur correspondante. Pour regrouper des modalités, il suffit de leur assigner des nouvelles valeurs identiques. Dans tous les cas n’hésitez pas à expérimenter, l’interface se contente de générer du code R à copier/coller dans votre script mais ne l’exécute pas, et ne modifie donc jamais vos données !</p>
L’onglet <em>Vérification</em> affiche un tri croisé de l’ancienne et de la nouvelle variable pour vérifier que le recodage est correct. Une fois le résultat satisfaisant, vous pouvez récupérer le code généré dans l’onglet <em>Code</em> pour l’inclure dans votre script.
</div>
</div>
<div id="variables-calculees" class="section level3">
<h3>Variables calculées</h3>
<p>La création d’une variable numérique à partir de calculs sur une ou plusieurs autres variables numériques se fait très simplement.</p>
<p>Supposons que l’on souhaite calculer une variable indiquant l’écart entre le nombre d’heures passées à regarder la télévision et la moyenne globale de cette variable. On pourrait alors faire :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">range</span>(d$heures.tv, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</code></pre>
<pre><code>[1]  0 12</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mean</span>(d$heures.tv, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</code></pre>
<pre><code>[1] 2.246566</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">d$ecart.heures.tv &lt;-<span class="st"> </span>d$heures.tv -<span class="st"> </span><span class="kw">mean</span>(d$heures.tv, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
<span class="kw">range</span>(d$ecart.heures.tv, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</code></pre>
<pre><code>[1] -2.246566  9.753434</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mean</span>(d$ecart.heures.tv, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</code></pre>
<pre><code>[1] 4.714578e-17</code></pre>
<p>Autre exemple tiré du jeu de données <code>rp99</code> : si on souhaite calculer le pourcentage d’actifs dans chaque commune, on peut diviser la population active <em>pop.act</em> par la population totale <em>pop.tot</em>.</p>
<pre class="sourceCode r"><code class="sourceCode r">rp99$part.actifs &lt;-<span class="st"> </span>rp99$pop.act/rp99$pop.tot *<span class="st"> </span><span class="dv">100</span></code></pre>
</div>
<div id="combiner-plusieurs-variables" class="section level3">
<h3>Combiner plusieurs variables</h3>
<p>La combinaison de plusieurs variables se fait à l’aide des techniques d’indexation déjà décrites précédemment. Le plus compliqué est d’arriver à formuler des conditions parfois complexes de manière rigoureuse.</p>
<p>On peut ainsi vouloir combiner plusieurs variables qualitatives en une seule :</p>
<pre class="sourceCode r"><code class="sourceCode r">d$act.manuelles &lt;-<span class="st"> </span><span class="ot">NA</span>
d$act.manuelles[d$cuisine ==<span class="st"> &quot;Oui&quot;</span> &amp;<span class="st"> </span>d$bricol ==<span class="st"> &quot;Oui&quot;</span>] &lt;-<span class="st"> &quot;Cuisine et Bricolage&quot;</span>
d$act.manuelles[d$cuisine ==<span class="st"> &quot;Oui&quot;</span> &amp;<span class="st"> </span>d$bricol ==<span class="st"> &quot;Non&quot;</span>] &lt;-<span class="st"> &quot;Cuisine seulement&quot;</span>
d$act.manuelles[d$cuisine ==<span class="st"> &quot;Non&quot;</span> &amp;<span class="st"> </span>d$bricol ==<span class="st"> &quot;Oui&quot;</span>] &lt;-<span class="st"> &quot;Bricolage seulement&quot;</span>
d$act.manuelles[d$cuisine ==<span class="st"> &quot;Non&quot;</span> &amp;<span class="st"> </span>d$bricol ==<span class="st"> &quot;Non&quot;</span>] &lt;-<span class="st"> &quot;Ni cuisine ni bricolage&quot;</span>
<span class="kw">table</span>(d$act.manuelles)</code></pre>
<pre><code>
    Bricolage seulement    Cuisine et Bricolage       Cuisine seulement 
                    437                     416                     465 
Ni cuisine ni bricolage 
                    682 </code></pre>
<p>On peut également combiner variables qualitatives et variables quantitatives :</p>
<pre class="sourceCode r"><code class="sourceCode r">d$age.sexe &lt;-<span class="st"> </span><span class="ot">NA</span>
d$age.sexe[d$sexe ==<span class="st"> &quot;Homme&quot;</span> &amp;<span class="st"> </span>d$age &lt;<span class="st"> </span><span class="dv">40</span>] &lt;-<span class="st"> &quot;Homme moins de 40 ans&quot;</span>
d$age.sexe[d$sexe ==<span class="st"> &quot;Homme&quot;</span> &amp;<span class="st"> </span>d$age &gt;=<span class="st"> </span><span class="dv">40</span>] &lt;-<span class="st"> &quot;Homme plus de 40 ans&quot;</span>
d$age.sexe[d$sexe ==<span class="st"> &quot;Femme&quot;</span> &amp;<span class="st"> </span>d$age &lt;<span class="st"> </span><span class="dv">40</span>] &lt;-<span class="st"> &quot;Femme moins de 40 ans&quot;</span>
d$age.sexe[d$sexe ==<span class="st"> &quot;Femme&quot;</span> &amp;<span class="st"> </span>d$age &gt;=<span class="st"> </span><span class="dv">40</span>] &lt;-<span class="st"> &quot;Femme plus de 40 ans&quot;</span>
<span class="kw">table</span>(d$age.sexe)</code></pre>
<pre><code>
Femme moins de 40 ans  Femme plus de 40 ans Homme moins de 40 ans 
                  376                   725                   315 
 Homme plus de 40 ans 
                  584 </code></pre>
<p>Les combinaisons de variables un peu complexes nécessitent parfois un petit travail de réflexion. En particulier, l’ordre des commandes de recodage a parfois une influence dans le résultat final.</p>
</div>
<div id="variables-scores" class="section level3">
<h3>Variables scores</h3>
<p>Une variable score est une variable calculée en additionnant des poids accordés aux modalités d’une série de variables qualitatives.</p>
<p>Pour prendre un exemple tout à fait arbitraire, imaginons que nous souhaitons calculer un score d’activités extérieures. Dans ce score on considère que le fait d’aller au cinéma « pèse » 10, celui de pêcher ou chasser vaut 30 et celui de faire du sport vaut 20. On pourrait alors calculer notre score de la manière suivante :</p>
<pre class="sourceCode r"><code class="sourceCode r">d$score.ext &lt;-<span class="st"> </span><span class="dv">0</span>
d$score.ext[d$cinema ==<span class="st"> &quot;Oui&quot;</span>] &lt;-<span class="st"> </span>d$score.ext[d$cinema ==<span class="st"> &quot;Oui&quot;</span>] +<span class="st"> </span><span class="dv">10</span>
d$score.ext[d$peche.chasse ==<span class="st"> &quot;Oui&quot;</span>] &lt;-<span class="st"> </span>d$score.ext[d$peche.chasse ==<span class="st"> &quot;Oui&quot;</span>] +<span class="st"> </span>
<span class="st">    </span><span class="dv">30</span>
d$score.ext[d$sport ==<span class="st"> &quot;Oui&quot;</span>] &lt;-<span class="st"> </span>d$score.ext[d$sport ==<span class="st"> &quot;Oui&quot;</span>] +<span class="st"> </span><span class="dv">20</span>
<span class="kw">table</span>(d$score.ext)</code></pre>
<pre><code>
  0  10  20  30  40  50  60 
800 342 229 509  31  41  48 </code></pre>
<p>Cette notation étant un peu lourde, on peut l’alléger un peu en utilisant la fonction <code data-package="ifelse">ifelse</code>. Celle-ci prend en argument une condition et deux valeurs. Si la condition est vraie elle retourne la première valeur, sinon elle retourne la seconde.</p>
<pre class="sourceCode r"><code class="sourceCode r">d$score.ext &lt;-<span class="st"> </span><span class="dv">0</span>
d$score.ext &lt;-<span class="st"> </span><span class="kw">ifelse</span>(d$cinema ==<span class="st"> &quot;Oui&quot;</span>, <span class="dv">10</span>, <span class="dv">0</span>) +<span class="st"> </span><span class="kw">ifelse</span>(d$peche.chasse ==<span class="st"> &quot;Oui&quot;</span>, 
    <span class="dv">30</span>, <span class="dv">0</span>) +<span class="st"> </span><span class="kw">ifelse</span>(d$sport ==<span class="st"> &quot;Oui&quot;</span>, <span class="dv">20</span>, <span class="dv">0</span>)
<span class="kw">table</span>(d$score.ext)</code></pre>
<pre><code>
  0  10  20  30  40  50  60 
800 342 229 509  31  41  48 </code></pre>
</div>
<div id="verification-des-recodages" class="section level3">
<h3>Vérification des recodages</h3>
<p>Il est très important de vérifier, notamment après les recodages les plus complexes, qu’on a bien obtenu le résultat escompté. Les deux points les plus sensibles étant les valeurs manquantes et les erreurs dans les conditions.</p>
<p>Pour vérifier tout cela le plus simple est sans doute de faire des tableaux croisés entre la variable recodée et celles ayant servi au recodage, à l’aide de la fonction <code data-package="base">table</code>, et de vérifier le nombre de valeurs manquantes dans la variable recodée avec <code data-package="base">summary</code>, <code data-package="questionr">freq</code> ou <code data-package="base">table</code>.</p>
<p>Par exemple :</p>
<pre class="sourceCode r"><code class="sourceCode r">d$act.manuelles &lt;-<span class="st"> </span><span class="ot">NA</span>
d$act.manuelles[d$cuisine ==<span class="st"> &quot;Oui&quot;</span> &amp;<span class="st"> </span>d$bricol ==<span class="st"> &quot;Oui&quot;</span>] &lt;-<span class="st"> &quot;Cuisine et Bricolage&quot;</span>
d$act.manuelles[d$cuisine ==<span class="st"> &quot;Oui&quot;</span> &amp;<span class="st"> </span>d$bricol ==<span class="st"> &quot;Non&quot;</span>] &lt;-<span class="st"> &quot;Cuisine seulement&quot;</span>
d$act.manuelles[d$cuisine ==<span class="st"> &quot;Non&quot;</span> &amp;<span class="st"> </span>d$bricol ==<span class="st"> &quot;Oui&quot;</span>] &lt;-<span class="st"> &quot;Bricolage seulement&quot;</span>
d$act.manuelles[d$cuisine ==<span class="st"> &quot;Non&quot;</span> &amp;<span class="st"> </span>d$bricol ==<span class="st"> &quot;Non&quot;</span>] &lt;-<span class="st"> &quot;Ni cuisine ni bricolage&quot;</span>
<span class="kw">table</span>(d$act.manuelles, d$cuisine)</code></pre>
<pre><code>                         
                          Non Oui
  Bricolage seulement     437   0
  Cuisine et Bricolage      0 416
  Cuisine seulement         0 465
  Ni cuisine ni bricolage 682   0</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(d$act.manuelles, d$bricol)</code></pre>
<pre><code>                         
                          Non Oui
  Bricolage seulement       0 437
  Cuisine et Bricolage      0 416
  Cuisine seulement       465   0
  Ni cuisine ni bricolage 682   0</code></pre>
</div>
</div>
<div id="tri-de-tables" class="section level2">
<h2>Tri de tables</h2>
<p>La fonction <code data-package="base">sort</code> permet de trier les éléments d’un vecteur.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sort</span>(<span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">1</span>, <span class="dv">8</span>))</code></pre>
<pre><code>[1] 1 2 5 6 8</code></pre>
<p>On peut appliquer cette fonction à une variable, mais celle-ci ne permet que d’ordonner les valeurs de cette variable, et pas l’ensemble du tableau de données dont elle fait partie. Pour cela nous avons besoin d’une autre fonction, nommée <code data-package="base">order</code>. Celle-ci ne renvoie pas les valeurs du vecteur triées, mais les emplacements de ces valeurs.</p>
<p>Un exemple pour comprendre :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">order</span>(<span class="kw">c</span>(<span class="dv">15</span>, <span class="dv">20</span>, <span class="dv">10</span>))</code></pre>
<pre><code>[1] 3 1 2</code></pre>
<p>Le résultat renvoyé signifie que la plus petite valeur est la valeur située en 3<sup>e</sup> position, suivie de celle en 1<sup>ère</sup> position et de celle en 2<sup>e</sup> position. Tout cela ne paraît pas passionnant à première vue, mais si on mélange ce résultat avec un peu d’indexation directe, ça devient intéressant. . .</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(<span class="kw">order</span>(d$age))</code></pre>
<pre><code>[1] 162 215 346 377 511 646</code></pre>
<p>Ce que cette fonction renvoie, c’est l’ordre dans lequel on doit placer les éléments de age, et donc par extension les lignes de <code>d</code>, pour que la variable soit triée par ordre croissant. Par conséquent, si on fait :</p>
<pre class="sourceCode r"><code class="sourceCode r">d.tri &lt;-<span class="st"> </span>d[<span class="kw">order</span>(d$age), ]</code></pre>
<p>Alors on a trié les lignes de d par ordre d’âge croissant ! Et si on fait un petit :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(d.tri, <span class="dv">3</span>)</code></pre>
<pre><code>     id age  sexe nivetud    poids           occup qualif freres.soeurs
162 162  18 Homme    &lt;NA&gt; 4982.964 Etudiant, eleve   &lt;NA&gt;             2
215 215  18 Homme    &lt;NA&gt; 4631.188 Etudiant, eleve   &lt;NA&gt;             2
346 346  18 Femme    &lt;NA&gt; 1725.410 Etudiant, eleve   &lt;NA&gt;             9
    clso                       relig trav.imp trav.satisf hard.rock
162  Non  Appartenance sans pratique     &lt;NA&gt;        &lt;NA&gt;       Non
215  Oui Ni croyance ni appartenance     &lt;NA&gt;        &lt;NA&gt;       Non
346  Non         Pratiquant regulier     &lt;NA&gt;        &lt;NA&gt;       Non
    lecture.bd peche.chasse cuisine bricol cinema sport heures.tv fs.fac
162        Non          Non     Non    Non    Non   Oui         3      2
215        Non          Non     Oui    Non    Oui   Oui         2      2
346        Non          Non     Non    Non    Oui   Non         2      9
    fs.char qualif.char      age5cl  age20  age6cl qualif.reg
162       2        &lt;NA&gt; (17.9,33.8] &lt;20ans [18,30)       &lt;NA&gt;
215       2        &lt;NA&gt; (17.9,33.8] &lt;20ans [18,30)       &lt;NA&gt;
346       9        &lt;NA&gt; (17.9,33.8] &lt;20ans [18,30)       &lt;NA&gt;
    trav.satisf.reg ecart.heures.tv           act.manuelles
162        Manquant       0.7534336 Ni cuisine ni bricolage
215        Manquant      -0.2465664       Cuisine seulement
346        Manquant      -0.2465664 Ni cuisine ni bricolage
                 age.sexe score.ext
162 Homme moins de 40 ans        20
215 Homme moins de 40 ans        30
346 Femme moins de 40 ans        10</code></pre>
<p>On a les caractéristiques des trois enquêtés les plus jeunes.</p>
<p>On peut évidemment trier par ordre décroissant en utilisant l’option <code>decreasing=TRUE</code>. On peut donc afficher les caractéristiques des trois individus les plus âgés avec :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(d[<span class="kw">order</span>(d$age, <span class="dt">decreasing =</span> <span class="ot">TRUE</span>), ], <span class="dv">3</span>)</code></pre>
<pre><code>       id age  sexe                           nivetud    poids
1916 1916  97 Femme Derniere annee d&#39;etudes primaires 2162.835
270   270  96 Femme Derniere annee d&#39;etudes primaires 9993.020
1542 1542  93 Femme Derniere annee d&#39;etudes primaires 7107.841
                   occup qualif freres.soeurs clso
1916       Autre inactif  Autre             5  Non
270             Retraite   &lt;NA&gt;             1  Oui
1542 Retire des affaires   &lt;NA&gt;             7  Non
                           relig trav.imp trav.satisf hard.rock lecture.bd
1916      Pratiquant occasionnel     &lt;NA&gt;        &lt;NA&gt;       Non        Non
270  Ni croyance ni appartenance     &lt;NA&gt;        &lt;NA&gt;       Non        Non
1542      Pratiquant occasionnel     &lt;NA&gt;        &lt;NA&gt;       Non        Non
     peche.chasse cuisine bricol cinema sport heures.tv fs.fac fs.char
1916          Non     Non    Non    Non   Non         3      5       5
270           Non     Non    Non    Non   Non         6      1       1
1542          Non     Non    Non    Oui   Non         3      7       7
     qualif.char      age5cl  age20  age6cl qualif.reg trav.satisf.reg
1916       Autre (81.2,97.1]   &lt;NA&gt; [66,97]      Autre        Manquant
270         &lt;NA&gt; (81.2,97.1]   &lt;NA&gt; [66,97]       &lt;NA&gt;        Manquant
1542        &lt;NA&gt; (81.2,97.1] &gt;80ans [66,97]       &lt;NA&gt;        Manquant
     ecart.heures.tv           act.manuelles             age.sexe
1916       0.7534336 Ni cuisine ni bricolage Femme plus de 40 ans
270        3.7534336 Ni cuisine ni bricolage Femme plus de 40 ans
1542       0.7534336 Ni cuisine ni bricolage Femme plus de 40 ans
     score.ext
1916         0
270          0
1542        10</code></pre>
</div>
<div id="fusion-de-tables" class="section level2">
<h2>Fusion de tables</h2>
<p>Lorsqu’on traite de grosses enquêtes, notamment les enquêtes de l’INSEE, on a souvent à gérer des données réparties dans plusieurs tables, soit du fait de la construction du questionnaire, soit du fait de contraintes techniques (fichiers <strong>dbf</strong> ou <strong>Excel</strong> limités à 256 colonnes, par exemple).</p>
<p>Une opération relativement courante consiste à fusionner plusieurs tables pour regrouper tout ou partie des données dans un unique tableau.</p>
<p>Nous allons simuler artificiellement une telle situation en créant deux tables à partir de l’extrait de l’enquête <em>Histoire de vie</em> :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(hdv2003)
d &lt;-<span class="st"> </span>hdv2003
<span class="kw">dim</span>(d)</code></pre>
<pre><code>[1] 2000   20</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">d1 &lt;-<span class="st"> </span><span class="kw">subset</span>(d, <span class="dt">select =</span> <span class="kw">c</span>(<span class="st">&quot;id&quot;</span>, <span class="st">&quot;age&quot;</span>, <span class="st">&quot;sexe&quot;</span>))
<span class="kw">dim</span>(d1)</code></pre>
<pre><code>[1] 2000    3</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">d2 &lt;-<span class="st"> </span><span class="kw">subset</span>(d, <span class="dt">select =</span> <span class="kw">c</span>(<span class="st">&quot;id&quot;</span>, <span class="st">&quot;clso&quot;</span>))
<span class="kw">dim</span>(d2)</code></pre>
<pre><code>[1] 2000    2</code></pre>
<p>On a donc deux tableaux de données, <code>d1</code> et <code>d2</code>, comportant chacun 2000 lignes et respectivement 3 et 2 colonnes. Comment les rassembler pour n’en former qu’un ?</p>
<p>Intuitivement, cela paraît simple. Il suffit de « coller » <code>d2</code> à la droite de <code>d1</code>, comme dans l’exemple suivant.</p>
<style media="screen" type="text/css">
table.exemple_df td, 
table.exemple_df th {
  text-align: center;
  padding: 3px 10px;
}
table.exemple_df th {
  border-bottom: solid 1px #999;
}

table.exemple_df td + td,
table.exemple_df th + th {
  border-left: solid 1px #999;
}

table.exemple_operateur td {
  font-size: 3em;
  padding: 20px;
}
</style>
<table style="margin: 11px auto;">
<tr>
<td>
<table class="exemple_df">
<tr>
<th>
id
</th>
<th>
v1
</th>
<th>
v2
</th>
</tr>
<tr>
<td>
1
</td>
<td>
H
</td>
<td>
12
</td>
</tr>
<tr>
<td>
2
</td>
<td>
H
</td>
<td>
17
</td>
</tr>
<tr>
<td>
3
</td>
<td>
F
</td>
<td>
41
</td>
</tr>
<tr>
<td>
4
</td>
<td>
F
</td>
<td>
9
</td>
</tr>
<tr>
<td>
…
</td>
<td>
…
</td>
<td>
…
</td>
</tr>
</table>
</td>
<td>
<table class="exemple_operateur">
<tr>
<td>
+
</td>
</tr>
</table>
</td>
<td>
<table class="exemple_df">
<tr>
<th>
id
</th>
<th>
v3
</th>
</tr>
<tr>
<td>
1
</td>
<td>
rouge
</td>
</tr>
<tr>
<td>
2
</td>
<td>
bleu
</td>
</tr>
<tr>
<td>
3
</td>
<td>
bleu
</td>
</tr>
<tr>
<td>
4
</td>
<td>
rouge
</td>
</tr>
<tr>
<td>
…
</td>
<td>
…
</td>
<td>
…
</td>
</tr>
</table>
</td>
<td>
<table class="exemple_operateur">
<tr>
<td>
=
</td>
</tr>
</table>
</td>
<td>
<table class="exemple_df">
<tr>
<th>
id
</th>
<th>
v1
</th>
<th>
v2
</th>
<th>
v3
</th>
</tr>
<tr>
<td>
1
</td>
<td>
H
</td>
<td>
12
</td>
<td>
rouge
</td>
</tr>
<tr>
<td>
2
</td>
<td>
H
</td>
<td>
17
</td>
<td>
bleu
</td>
</tr>
<tr>
<td>
3
</td>
<td>
F
</td>
<td>
41
</td>
<td>
bleu
</td>
</tr>
<tr>
<td>
4
</td>
<td>
F
</td>
<td>
9
</td>
<td>
rouge
</td>
</tr>
<tr>
<td>
…
</td>
<td>
…
</td>
<td>
…
</td>
<td>
…
</td>
</tr>
</table>
</td>
</tr>
</table>
<p>Cela semble fonctionner. La fonction qui permet d’effectuer cette opération sous <strong>R</strong> s’appelle <code data-package="base">cbind</code>, elle « colle » des tableaux côte à côte en regroupant leurs colonnes<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(<span class="kw">cbind</span>(d1, d2))</code></pre>
<pre><code>  id age  sexe id clso
1  1  28 Femme  1  Oui
2  2  23 Femme  2  Oui
3  3  59 Homme  3  Non
4  4  34 Homme  4  Non
5  5  71 Femme  5  Oui
6  6  35 Femme  6  Non</code></pre>
<p>À part le fait qu’on a une colonne <em>id</em> en double, le résultat semble satisfaisant. À première vue seulement. Imaginons maintenant que nous avons travaillé sur <code>d1</code> et <code>d2</code>, et que nous avons ordonné les lignes de d1 selon l’âge des enquêtés :</p>
<pre class="sourceCode r"><code class="sourceCode r">d1 &lt;-<span class="st"> </span>d1[<span class="kw">order</span>(d1$age), ]</code></pre>
<p>Répétons l’opération de collage :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(<span class="kw">cbind</span>(d1, d2))</code></pre>
<pre><code>     id age  sexe id clso
162 162  18 Homme  1  Oui
215 215  18 Homme  2  Oui
346 346  18 Femme  3  Non
377 377  18 Homme  4  Non
511 511  18 Homme  5  Oui
646 646  18 Homme  6  Non</code></pre>
<p>Que constate-t-on ? La présence de la variable <em>id</em> en double nous permet de voir que les identifiants ne coïncident plus ! En regroupant nos colonnes nous avons donc attribué à des individus les réponses d’autres individus.</p>
<p>La commande <code data-package="base">cbind</code> ne peut en effet fonctionner que si les deux tableaux ont exactement le même nombre de lignes, et dans le même ordre, ce qui n’est pas le cas ici.</p>
<p>On va donc être obligé de pocéder à une <em>fusion</em> des deux tableaux, qui va permettre de rendre à chaque ligne ce qui lui appartient. Pour cela nous avons besoin d’un identifiant qui permet d’identifier chaque ligne de manière unique et qui doit être présent dans tous les tableaux. Dans notre cas, c’est plutôt rapide, il s’agit de la variable <em>id</em>.</p>
<p>Une fois l’identifiant identifié<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>, on peut utiliser la commande <code data-package="base">merge</code>. Celle-ci va fusionner les deux tableaux en supprimant les colonnes en double et en regroupant les lignes selon leurs identifiants :</p>
<pre class="sourceCode r"><code class="sourceCode r">d.complet &lt;-<span class="st"> </span><span class="kw">merge</span>(d1, d2, <span class="dt">by =</span> <span class="st">&quot;id&quot;</span>)
<span class="kw">head</span>(d.complet)</code></pre>
<pre><code>  id age  sexe clso
1  1  28 Femme  Oui
2  2  23 Femme  Oui
3  3  59 Homme  Non
4  4  34 Homme  Non
5  5  71 Femme  Oui
6  6  35 Femme  Non</code></pre>
<p>Ici l’utilisation de la fonction est plutôt simple car nous sommes dans le cas de figure idéal : les lignes correspondent parfaitement et l’identifiant est clairement identifié. Parfois les choses peuvent être un peu plus compliquées :</p>
<ul>
<li>parfois les identifiants n’ont pas le même nom dans les deux tableaux. On peut alors les spécifier par les options <code>by.x</code> et <code>by.y</code> ;</li>
<li>parfois les deux tableaux comportent des colonnes (hors identifiants) ayant le même nom. <code data-package="base">merge</code> conserve dans ce cas ces deux colonnes mais les renomme en les suffixant par <em>.x</em> pour celles provenant du premier tableau et <em>.y</em> pour celles du second ;</li>
<li>parfois on n’a pas d’identifiant unique préétabli, mais on en construit un à partir de plusieurs variables. On peut alors donner un vecteur en paramètres de l’option <code>by</code>, par exemple <code>by=c(&quot;nom&quot;,&quot;prenom&quot;,&quot;date.naissance&quot;)</code>.</li>
</ul>
<p>Une subtilité supplémentaire intervient lorsque les deux tableaux fusionnés n’ont pas exactement les mêmes lignes. Par défaut, <code data-package="base">merge</code> ne conserve que les lignes présentes dans les deux tableaux :</p>
<table style="margin: 11px auto;">
<tr>
<td>
<table class="exemple_df">
<tr>
<th>
id
</th>
<th>
v1
</th>
</tr>
<tr>
<td>
1
</td>
<td>
H
</td>
</tr>
<tr>
<td>
2
</td>
<td>
H
</td>
</tr>
<tr>
<td>
3
</td>
<td>
F
</td>
</tr>
</table>
</td>
<td>
<table class="exemple_operateur">
<tr>
<td>
+
</td>
</tr>
</table>
</td>
<td>
<table class="exemple_df">
<tr>
<th>
id
</th>
<th>
v2
</th>
</tr>
<tr>
<td>
1
</td>
<td>
10
</td>
</tr>
<tr>
<td>
2
</td>
<td>
15
</td>
</tr>
<tr>
<td>
5
</td>
<td>
31
</td>
</tr>
</table>
</td>
<td>
<table class="exemple_operateur">
<tr>
<td>
=
</td>
</tr>
</table>
</td>
<td>
<table class="exemple_df">
<tr>
<th>
id
</th>
<th>
v1
</th>
<th>
v2
</th>
</tr>
<tr>
<td>
1
</td>
<td>
H
</td>
<td>
10
</td>
</tr>
<tr>
<td>
2
</td>
<td>
H
</td>
<td>
15
</td>
</tr>
</table>
</td>
</tr>
</table>
<p>On peut cependant modifier ce comportement avec les options <code>all.x</code> et <code>all.y</code>.</p>
<p>Ainsi, <code>all.x=TRUE</code> indique de conserver toutes les lignes du premier tableau. Dans ce cas <code data-package="base">merge</code> donne une valeur <code>NA</code> pour ces lignes aux colonnes provenant du second tableau. Ce qui donnerait :</p>
<table style="margin: 11px auto;">
<tr>
<td>
<table class="exemple_df">
<tr>
<th>
id
</th>
<th>
v1
</th>
</tr>
<tr>
<td>
1
</td>
<td>
H
</td>
</tr>
<tr>
<td>
2
</td>
<td>
H
</td>
</tr>
<tr>
<td>
3
</td>
<td>
F
</td>
</tr>
</table>
</td>
<td>
<table class="exemple_operateur">
<tr>
<td>
+
</td>
</tr>
</table>
</td>
<td>
<table class="exemple_df">
<tr>
<th>
id
</th>
<th>
v2
</th>
</tr>
<tr>
<td>
1
</td>
<td>
10
</td>
</tr>
<tr>
<td>
2
</td>
<td>
15
</td>
</tr>
<tr>
<td>
5
</td>
<td>
31
</td>
</tr>
</table>
</td>
<td>
<table class="exemple_operateur">
<tr>
<td>
=
</td>
</tr>
</table>
</td>
<td>
<table class="exemple_df">
<tr>
<th>
id
</th>
<th>
v1
</th>
<th>
v2
</th>
</tr>
<tr>
<td>
1
</td>
<td>
H
</td>
<td>
10
</td>
</tr>
<tr>
<td>
2
</td>
<td>
H
</td>
<td>
15
</td>
</tr>
<tr>
<td>
3
</td>
<td>
F
</td>
<td>
<code>NA</code>
</td>
</tr>
</table>
</td>
</tr>
</table>
<p>L’option <code>all.y=TRUE</code> fait la même chose en conservant toutes les lignes du second tableau.</p>
<table style="margin: 11px auto;">
<tr>
<td>
<table class="exemple_df">
<tr>
<th>
id
</th>
<th>
v1
</th>
</tr>
<tr>
<td>
1
</td>
<td>
H
</td>
</tr>
<tr>
<td>
2
</td>
<td>
H
</td>
</tr>
<tr>
<td>
3
</td>
<td>
F
</td>
</tr>
</table>
</td>
<td>
<table class="exemple_operateur">
<tr>
<td>
+
</td>
</tr>
</table>
</td>
<td>
<table class="exemple_df">
<tr>
<th>
id
</th>
<th>
v2
</th>
</tr>
<tr>
<td>
1
</td>
<td>
10
</td>
</tr>
<tr>
<td>
2
</td>
<td>
15
</td>
</tr>
<tr>
<td>
5
</td>
<td>
31
</td>
</tr>
</table>
</td>
<td>
<table class="exemple_operateur">
<tr>
<td>
=
</td>
</tr>
</table>
</td>
<td>
<table class="exemple_df">
<tr>
<th>
id
</th>
<th>
v1
</th>
<th>
v2
</th>
</tr>
<tr>
<td>
1
</td>
<td>
H
</td>
<td>
10
</td>
</tr>
<tr>
<td>
2
</td>
<td>
H
</td>
<td>
15
</td>
</tr>
<tr>
<td>
5
</td>
<td>
<code>NA</code>
</td>
<td>
31
</td>
</tr>
</table>
</td>
</tr>
</table>
<p>Enfin, on peut décider de conserver toutes les lignes des deux tableaux en utilisant à la fois <code>all.x=TRUE</code> et <code>all.y=TRUE</code>, ce qui donne :</p>
<table style="margin: 11px auto;">
<tr>
<td>
<table class="exemple_df">
<tr>
<th>
id
</th>
<th>
v1
</th>
</tr>
<tr>
<td>
1
</td>
<td>
H
</td>
</tr>
<tr>
<td>
2
</td>
<td>
H
</td>
</tr>
<tr>
<td>
3
</td>
<td>
F
</td>
</tr>
</table>
</td>
<td>
<table class="exemple_operateur">
<tr>
<td>
+
</td>
</tr>
</table>
</td>
<td>
<table class="exemple_df">
<tr>
<th>
id
</th>
<th>
v2
</th>
</tr>
<tr>
<td>
1
</td>
<td>
10
</td>
</tr>
<tr>
<td>
2
</td>
<td>
15
</td>
</tr>
<tr>
<td>
5
</td>
<td>
31
</td>
</tr>
</table>
</td>
<td>
<table class="exemple_operateur">
<tr>
<td>
=
</td>
</tr>
</table>
</td>
<td>
<table class="exemple_df">
<tr>
<th>
id
</th>
<th>
v1
</th>
<th>
v2
</th>
</tr>
<tr>
<td>
1
</td>
<td>
H
</td>
<td>
10
</td>
</tr>
<tr>
<td>
2
</td>
<td>
H
</td>
<td>
15
</td>
</tr>
<tr>
<td>
3
</td>
<td>
F
</td>
<td>
<code>NA</code>
</td>
</tr>
<tr>
<td>
5
</td>
<td>
<code>NA</code>
</td>
<td>
31
</td>
</tr>
</table>
</td>
</tr>
</table>
<p>Parfois, l’un des identifiants est présent à plusieurs reprises dans l’un des tableaux (par exemple lorsque l’une des tables est un ensemble de ménages et que l’autre décrit l’ensemble des individus de ces ménages). Dans ce cas les lignes de l’autre table sont dupliquées autant de fois que nécessaires :</p>
<table style="margin: 11px auto;">
<tr>
<td>
<table class="exemple_df">
<tr>
<th>
id
</th>
<th>
v1
</th>
</tr>
<tr>
<td>
1
</td>
<td>
H
</td>
</tr>
<tr>
<td>
2
</td>
<td>
H
</td>
</tr>
<tr>
<td>
3
</td>
<td>
F
</td>
</tr>
</table>
</td>
<td>
<table class="exemple_operateur">
<tr>
<td>
+
</td>
</tr>
</table>
</td>
<td>
<table class="exemple_df">
<tr>
<th>
id
</th>
<th>
v2
</th>
</tr>
<tr>
<td>
1
</td>
<td>
10
</td>
</tr>
<tr>
<td>
1
</td>
<td>
18
</td>
</tr>
<tr>
<td>
1
</td>
<td>
21
</td>
</tr>
<tr>
<td>
2
</td>
<td>
15
</td>
</tr>
<tr>
<td>
3
</td>
<td>
42
</td>
</tr>
</table>
</td>
<td>
<table class="exemple_operateur">
<tr>
<td>
=
</td>
</tr>
</table>
</td>
<td>
<table class="exemple_df">
<tr>
<th>
id
</th>
<th>
v1
</th>
<th>
v2
</th>
</tr>
<tr>
<td>
1
</td>
<td>
H
</td>
<td>
10
</td>
</tr>
<tr>
<td>
1
</td>
<td>
H
</td>
<td>
18
</td>
</tr>
<tr>
<td>
1
</td>
<td>
H
</td>
<td>
21
</td>
</tr>
<tr>
<td>
2
</td>
<td>
H
</td>
<td>
15
</td>
</tr>
<tr>
<td>
3
</td>
<td>
F
</td>
<td>
42
</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Une différence entre les deux est que <code>$</code> admet une correspondance partielle du nom de variable, si celle-ci est unique. Ainsi, <code>d$cls</code> renverra bien la variable <em>clso</em>, tandis que <code>d$c</code> renverra <code>NULL</code>, du fait que plusieurs variables de <em>d</em> commencent par la lettre <em>c</em>.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Si vous utilisez l’extenstion <strong class="package">data.table</strong>, la gestion des valeurs manquantes est quelque peu différente. Voir chapitre MAJ_LIEN.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>L’équivalent de <code data-package="base">cbind</code> pour les lignes s’appelle <code data-package="base" data-rdocumentation="cbind">rbind</code>.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Si vous me passez l’expression. . .<a href="#fnref4">↩</a></p></li>
</ol>
</div>

<script>

// manage active state of menu based on current page
$(document).ready(function () {

    // active menu
    href = window.location.pathname
    href = href.substr(href.lastIndexOf('/') + 1)
    $('a[href="' + href + '"]').parent().addClass('active');

    // manage active menu header
    if (href.startsWith('pem_'))
      $('a[href="' + 'pem' + '"]').parent().addClass('active');
    else if (href.startsWith('analyses_'))
      $('a[href="' + 'analyses' + '"]').parent().addClass('active');
    else if (href.startsWith('astuces_'))
      $('a[href="' + 'astuces' + '"]').parent().addClass('active');

    // Identifier les <pre> fermant
    $('pre').next().not('pre').prev().addClass('last'); // Last <pre> of each group of <pre>
    $('pre').last().addClass('last'); // If the last one is not followed bay anything

    // Ajout liens rdocumentation
    $("code[data-package]").each(function( index ) {
      package = $(this).attr('data-package');
      if ($(this).attr('data-rdocumentation') !== undefined)
        rdocumentation = $(this).attr('data-rdocumentation');
      else
        rdocumentation = $(this).text();
      fonction = $(this).text();
      $(this).wrap('<a href="http://www.rdocumentation.org/packages/'+package+'/functions/'+rdocumentation+'">');
    });

    $("strong.package").each(function( index ) {
      $(this).wrap('<a href="http://www.rdocumentation.org/packages/'+$(this).text()+'">');
    });

    // Figures
    $("figure").each(function( index ) {
      if ($(this).children("figcaption").length > 0)
        $(this).children("figcaption:first").prepend('<span class="figure-number">Figure '+(index+1)+'.</span> ');
      else
        $(this).append($("<figcaption>").append('<span class="figure-number">Figure '+(index+1)+'</span>'));
    });

});
</script>

<!-- disqus -->
  <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'analyse-r'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Veuillez activer JavaScript pour voir les <a href="http://disqus.com/?ref_noscript">les commentaires gérés avec Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">Les commentaires sont hébergés par <span class="logo-disqus">Disqus</span>.</a>

</div>

<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});

</script>


</body>
</html>

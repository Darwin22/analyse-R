---
title: "Premier travail avec des données"
---

```{r options_communes, include=FALSE}
source("options_communes.R")
```

<div class="note">
Ce chapitre est inspiré de la section *Premier travail avec les données* du support de cours
[Introduction à R](https://github.com/juba/intro-r) réalisé par Julien Barnier.
</div>

## Regrouper les commandes dans des scripts

Jusqu'à maintenant nous avons utilisé uniquement la console pour communiquer avec **R** via l'invite de
commandes. Le principal problème de ce mode d'interaction est qu'une fois qu'une commande est tapée,
elle est pour ainsi dire « perdue », c'est-à-dire qu'on doit la saisir à nouveau si on veut l'exécuter une
seconde fois. L'utilisation de la console est donc restreinte aux petites commandes « jetables », le plus
souvent utilisées comme test.

La plupart du temps, les commandes seront stockées dans un fichier à part, que l'on pourra facilement
ouvrir, éditer et exécuter en tout ou partie si besoin. On appelle en général ce type de fichier un 
<dfn>script</dfn><dfn data-index="fichier de commandes"></dfn>.

Pour comprendre comment cela fonctionne, dans **RStudio** cliquez sur l'icône en haut à gauche représentant
un fichier avec un signe plus vert, puis choisissez *R script*.

<figure>
![Créer un nouveau script R dans RStudio](images/capture_RStudio_new_R_script.png)
<figcaption>Créer un nouveau script R dans RStudio</figcaption>
</figure>

Un nouvel onglet apparaît dans le quadrant supérieur gauche.

<figure>
![Onglet d'un script R dans RStudio](images/capture_RStudio_onglet_R_script.png)
<figcaption>Onglet d'un script R dans RStudio</figcaption>
</figure>

Nous pouvons désormais y saisir des commandes. Par
exemple, tapez sur la première ligne la commande suivante : `2 + 2`.
Ensuite, cliquez sur l'icône *Run* (en haut à droite de l'onglet du script) ou
bien pressez simulatément les touches <kbd>CTRL</kbd> et <kbd>Entrée</kbd>^[Sous 
**Mac OS X**, on utilise les touches <kbd>Pomme</kbd> et <kbd>Entrée</kbd>.].

Les lignes suivantes ont dû faire leur apparition dans la console :

```{r}
2 + 2
```

Voici donc comment soumettre rapidement à **R** les commandes saisies dans votre fichier. Vous pouvez
désormais l'enregistrer, l'ouvrir plus tard, et en exécuter tout ou partie. À noter que vous avez plusieurs
possibilités pour soumettre des commandes à **R** :

* vous pouvez exécuter la ligne sur laquelle se trouve votre curseur en cliquant sur *Run*
  ou en pressant simulatément les touches <kbd>CTRL</kbd> et <kbd>Entrée</kbd> ;
* vous pouvez sélectionner plusieurs lignes contenant des commandes et les exécuter toutes en 
  une seule fois exactement de la même manière ;
* vous pouvez exécuter d'un coup l'intégralité de votre fichier en cliquant sur l'icône
  *Source*.

La plupart du travail sous **R** consistera donc à éditer un ou plusieurs fichiers de commandes
et à envoyer régulièrement les commandes saisies à **R** en utilisant les raccourcis clavier *ad hoc*.

Pour plus d'information sur l'utilisation des scripts **R** dans **RStudio**, voir (en anglais) : 
<https://support.rstudio.com/hc/en-us/articles/200484448-Editing-and-Executing-Code>.

<div class="note">
Quand vous enregistrez un script sous **RStudio**, il est possible qu'il vous demande 
de choisir un type d'encodage des caractères (*Choose Encoding*). Si tel est le cas, 
utilisez de préférence **UTF-8**.
</div>

## Ajouter des commentaires

Un <dfn>commentaire</dfn> est une ligne ou une portion de ligne 
qui sera ignorée par **R**. Ceci signifie qu'on peut
y écrire ce qu'on veut et qu'on va les utiliser pour ajouter tout un tas de commentaires à notre code
permettant de décrire les différentes étapes du travail, les choses à se rappeler, les questions en suspens,
etc.

Un commentaire sous **R** commence par un ou plusieurs symboles `#` (qui s'obtient avec les touches
<kbd>Alt Gr</kbd> et <kbd>3</kbd> sur les claviers de type PC). Tout ce qui suit ce symbole jusqu'à 
la fin de la ligne est considéré comme un commentaire. 
On peut créer une ligne entière de commentaire en la faisant débuter par `##`. 
Par exemple :

```{r}
## Tableau croisé de la CSP par le nombre de livres lus.
## Attention au nombre de non réponses !
```

On peut aussi créer des commentaires pour une ligne en cours :

```{r}
x <- 2 # On met 2 dans x, parce qu'il le vaut bien
```

<div class="important">
Dans tous les cas, il est très important de documenter ses fichiers **R** au fur et à mesure, 
faute de quoi on risque de ne plus y comprendre grand chose si on les reprend ne serait-ce que 
quelques semaines plus tard.
</div>

Avec **RStudio**, vous pouvez également utiliser les commentaires pour créer des 
<dfn data-index="section">sections</dfn> au sein 
de votre script et naviguer plus rapidement. Il suffit de faire suivre une ligne de commentaires
d'au moins 4 signes moins (`----`). Par exemple, si vous saisissez ceci dans votre script :

```{r, eval=FALSE}
## Créer les objets ----

x <- 2
y <- 5

## Calculs ----

x + y
```

Vous verrez apparaître en bas à gauche de la fenêtre du script un symbole dièse orange. Si vous
cliquez dessus, un menu de navigation s'affichera vous permettant de vous déplacez rapidement au sein
de votre script. Pour plus d'information, voir la documentation de **RStudio** (en anglais) :
<https://support.rstudio.com/hc/en-us/articles/200484568-Code-Folding-and-Sections>.

<figure>
![Navigation rapide dans les scripts sous RStudio](images/capture_RStudio_navigation_script.png)
<figcaption>Navigation rapide dans les scripts sous RStudio</figcaption>
</figure>

Note : on remarquera au passage que le titre de l'onglet est affiché en rouge et suivi d'une
astérisque (`*`), nous indiquant ainsi qu'il y a des modifications non enregistrées dans notre
fichier.

## Tableaux de données

Dans cette partie nous allons utiliser un jeu de données comprenant les résultats d'une enquête
du type EDS (Enquête Démographie et de Santé). Il est composé de trois
<dfn data-index="tableau de donnée">tableaux de données</dfn> :

* une table `ménages` comportant quelques données sur les ménages sélectionnés pour l'enquête ;
* une table `femmes` comportant les données du questionnaire administré à toutes les femmes
  adultes (15-49 ans) habitant dans les ménages sélectionnés ;
* et une table `enfants` comportant des informations sur l'ensemble des naissances vivantes des
  femmes enquêtées.

Pour charger ces données en mémoire, on utilisera la commande suivante :

```{r, echo=FALSE}
load("data/enquete_menages.Rdata")
```

```{r, eval=FALSE}
load(url("http://larmarange.github.io/analyse-R/data/enquete_menages.Rdata"))
```

Bien. Et maintenant, elles sont où mes données ? Et bien elles se trouvent dans trois objets nommés
`menages`, `femmes` et `enfants`, désormais chargé en mémoire et accessible directement. D'ailleurs, 
ces objets sont maintenant visibles dans l'onglet *Environment* du quadrant supérieur droit.

Intéressons nous plus spécifiquement à l'objet `femmes`. Essayons de taper son nom à l'invite de commande :

```{r, eval=FALSE}
femmes
```

Le résultat (non reproduit ici) ne ressemble pas forcément à grand-chose... Il faut se rappeler que par
défaut, lorsqu'on lui fournit seulement un nom d'objet, **R** essaye de l'afficher de la manière la meilleure
(ou la moins pire) possible. La réponse à la commande `femmes` n'est donc rien moins que l'affichage des
données brutes contenues dans cet objet.

Ce qui signifie donc que l'intégralité du questionnaire femmes est inclus dans l'objet nommé `femmes` !
En effet, dans **R**, un objet peut très bien contenir un simple nombre, un vecteur ou bien le résultat d'une
enquête tout entière. Dans ce cas, les objets sont appelés des 
<dfn data-index="data frame" lang="en">data frames</dfn>, ou 
<dfn data-index="tableau de donnée">tableaux de données</dfn>. Ce type d'objet ressemble
aux fichiers de données que l'on a l'habitude de manipuler avec **SPSS**, **Stat**, **SAS**
ou encore **Excel**. Ils sont organisés en lignes et en colonnes, chaque colonne correspondant
à une <dfn>variable</dfn> et chaque ligne à une <dfn>observation</dfn>.

Les tableaux de données peuvent être manipulés comme tout autre objet. Par exemple :

```{r}
d <- femmes
```

va entraîner la copie de l'ensemble de nos données dans un nouvel objet nommé `d`, ce qui peut paraître
parfaitement inutile mais a en fait l'avantage de fournir un objet avec un nom beaucoup plus court, ce
qui diminuera la quantité de texte à saisir par la suite.

## Inspection visuelle des données{#inspecter}

La particularité de **R** par rapport à d'autres logiciels comme **Modalisa** ou **SPSS** est de 
ne pas proposer, par défaut, de vue des données sous forme de tableau. Ceci peut parfois être un peu
déstabilisant dans les premiers temps d'utilisation, même si l'on perd vite l'habitude et qu'on finit 
par se rendre compte que « voir » les données n'est pas forcément un gage de productivité ou de rigueur 
dans le traitement.

Néanmoins, **R** propose une interface permettant de visualiser le contenu d'un tableau de données
à l'aide de la fonction `View`{data-pkg="utils"} :

```{r, eval=FALSE}
View(d)
```

Sous **RStudio**, on peut aussi afficher la <dfn>visionneusee</dfn> 
(<dfn lang="en">viewer</dfn>) en cliquant sur la petite icône en forme 
de tableau située à droite de la ligne d'un tableau de données dans l'onglet *Environment* du
quadrant supérieur droit (cf. figure ci-après).

<figure>
![Icône pour afficher une vue du contenu d'un tableau](images/capture_RStudio_icone_viewer.png)
<figcaption>Icône pour afficher une vue du contenu d'un tableau</figcaption>
</figure>

Dans tous les cas, **RStudio** lancera le *viewer* dans un onglet dédié dans le quadrant supérieur
gauche. Le visualiseur de **RStudio** est plus avancé que celui-de base fournit par **R**. Il est
possible de trier les données selon une variable en cliquant sur le nom de cette dernière. Il y a
également un champs de recherche et un bouton *Filter* donnant accès à des options de filtrage
avancées.

<figure>
![La visionneuse de données de RStudio](images/capture_RStudio_data_viewer.png)
<figcaption>La visionneuse de données de RStudio</figcaption>
</figure>

## Structure du tableau

Avant de travailler sur les données, nous allons essayer de comprendre comment elles sont structurées. 
Lors de l'import de données depuis un autre logiciel (que nous aborderons dans un autre 
[chapitre](pem_import_export.html)), il s'agira souvent de vérifier que l'importation s'est bien déroulée.

Nous avons déjà vu qu'un tableau de données est organisé en lignes et en colonnes, les lignes correspondant aux 
<dfn data-index="observation">observations</dfn> et les colonnes aux 
<dfn data-index="variable">variables</dfn>. Les fonctions `nrow`{data-pkg="base"}, 
`ncol`{data-pkg="base" data-rdoc="nrow"} et `dim`{data-pkg="base"} donnent respectivement 
le nombre de lignes, le nombre de colonnes et les dimensions de notre tableau. Nous pouvons donc d'ores et 
déjà vérifier que nous avons bien 2000 lignes et 17 colonnes :

```{r}
nrow(d)
ncol(d)
dim(d)
```

La fonction `names`{data-pkg="base"} donne les noms des colonnes de notre tableau, c'est-à-dire 
les noms des variables :

```{r}
names(d)
```

Lorsque les données ont été importées depuis **SPSS**, **Stata** ou **SAS**, ont pu également
être importées des <dfn data-index="métadonnée">métadonnées</dfn> à propos de nos variables,
telles que des <dfn data-index="étiquette de variable">étiquettes de variable</dfn><dfn data-index="variable, étiquette"></dfn>,
c'est-à-dire un nom long décrivant la variable. Notre tableau de données `femmes` contient justement de telles
informations. Si vous vous souvenez bien, ces étiquettes étaient même affichées dans le *viewer* de
**RStudio**^[Il faut noter que la manière dont les méta-données sont stockées sous **R** dépend de l'extension
utilisée pour les importer. Le *viewer* de **RStudio** ne reconnait les étiquettes de variables que si les
données ont été importées avec l'extension `haven`{.pkg}. Nous y reviendrons dans le cadre du chapitre sur
l'[importation de données](pem_import_export.html).].

Pour afficher les étiquettes de variables, on pourra utiliser la fonction `lookfor`{data-pkg="questionr"}
de l'extension `questionr`{.pkg}. Les <dfn data-index="extension">extensions</dfn>, ou
<dfn data-index="package" lang="en">packages</dfn> en anglais, permettent d'étendre **R** en lui ajoutant
de nombreuses fonctionnalités. Pour accéder aux fonctions d'une extension, deux étapes sont nécessaires :

1. Tout d'abord l'extension doit avoir été installée sur votre ordinateur. Pour le vérifier, vous pouvez
   regarder si l'extension qui vous intéresse est listée dans l'onglet *Packages* dans le quadrant
   inférieur droit. Si ce n'est pas le cas, cliquez sur le bouton *Install* de l'onglet *Packages*.
   Pour plus de détails, vous pouvez vous référer au chapitre 
   [Présentation et Installation](pem_presentation_installation.html#installer_extensions).
2. Si l'extension désirée est bien installée, il est encore nécessaire de la charger en mémoire
   pour avoir accès aux fonctions qu'elle propose. Pour cela, on aura recours à la fonction
   `library`{data-pkg="base"}.
   
```{r}
library(questionr)
```

<div class="important">
Il est nécessaire de charger en mémoire les extensions requises au début de chaque session de travail.
Dès lors, plutôt que d'éparpiller les appels à `library`{data-pkg="base"} dans vos scripts, 
il est préférable de les regrouper au début de ces derniers.

On pourra noter qu'il n'est pas nécessaire d'entourer le nom d'une extension avec des guillemets lors d'un
appel à `library`{data-pkg="base"}. Les deux syntaxes suivantes sont donc équivalentes.

```{r}
library(questionr)
library("questionr")
```
</div>

Maintenant que l'extension `questionr`{.pkg} est chargée en mémoire, nous pouvons appeler la
fonction `lookfor`{data-pkg="questionr"} :

```{r}
lookfor(d)
```

Lorsque l'on a un gros tableau de données avec de nombreuses variables, il peut être difficile
de retrouver la ou les variables d'intérêt. Il est possible d'indiquer à `lookfor`{data-pkg="questionr"}
un mot-clé pour limiter la recherche. Par exemple :

```{r}
lookfor(d, "date")
lookfor(d, "re")
```

Il est à noter que si la recherche n'est pas sensible à la casse (i.e. aux majuscules et aux minuscules), 
elle est sensible aux accents.

Tous les tableaux de données ne contiennent pas forcément des métadonnées telles que les
étiquettes de variables. C'est le cas par exemple du tableau de données `iris`,
directement accessibles dans **R** et souvent utilisé pour les exemples de la 
documentation. Il contient les dimensions des sépales et des pétales de plusieurs espères
d'iris^[Pour plus d'information, tapez la commande `?iris`.]. Ce tableau de données ne contient
pas de métadonnées. Dans le cas là, la fonction `lookfor`{data-pkg="questionr"}ne renverra que 
les noms des variables :

```{r}
lookfor(iris)
```


## Accéder aux variables

`d` représente donc l'ensemble de notre tableau de données. Nous avons vu que si l'on saisit simplement
`d` à l'invite de commandes, on obtient un affichage du tableau en question. Mais comment accéder aux
variables, c'est à dire aux colonnes de notre tableau ?

La réponse est simple : on utilise le nom de l'objet, suivi de l'opérateur 
`$`{data-pkg="base" data-rdoc="Extract"}, suivi du nom de la variable,
comme ceci :

```{r, eval=FALSE}
d$age
```

Au regard du résultat (non reproduit ici), on constate alors que **R** a bien accédé au contenu 
de notre variable *sexe* du tableau `d` et a affiché son
contenu, c'est-à-dire l'ensemble des valeurs prises par la variable.

Les fonctions `head`{data-pkg="utils"} et `tail`{data-pkg="utils" data-rdoc="head"}
permettent d'afficher seulement les premières (respectivement les dernières)
valeurs prises par la variable. On peut leur passer en argument le nombre d'éléments à afficher :

```{r}
head(d$date_naissance)
tail(d$age, 10)
```

À noter que ces fonctions marchent aussi pour afficher les lignes du tableau `d` :

```{r}
head(d, 2)
```


## La fonction str

La fonction `str`{data-pkg="utils"} est plus complète que `names`{data-pkg="base"}. 
Elle liste les différentes variables, 
indique leur type et donne le cas échéant des informations supplémentaires ainsi qu'un échantillon 
des premières valeurs prises par cette variable :

```{r}
str(iris)
```

La première ligne nous informe qu'il s'agit bien d'un tableau de données avec 150 observations et
5 variables. Vient ensuite la liste des variables. Les quatre premières sont de type 
<dfn data-index="numérique, variable">numérique</dfn><dfn data-index="variable numérique"></dfn><dfn data-index="numeric" lang="en"></dfn>. La cinquième se nomme <var>Species</var> et il s'agit d'un 
<dfn>facteur</dfn> (<dfn lang="en">factor</dfn>).

Un facteur est une variable pouvant prendre un nombre limité de 
<dfn data-index="modalité, facteur">modalités</dfn> 
(<dfn data-index="level, factor" lang="en">levels</dfn>). Ici notre variable
a trois modalités possibles : « setosa », « versicolor » et « virginica ». 
Ce type de variable sera décrit plus en détail 
dans le chapitre sur la [manipulation de données](pem_manipulation.html#variables).

Appliquons maintenant la fonction `str`{data-pkg="utils"} à notre objet `d`.

```{r}
str(d)
```

Le résultat est à première vue un peu plus compliqué. C'est dû au fait que nos données
ont été importées depuis **SPSS** avec `haven`{.pkg} et contiennent dès lors des méta-données,
telles que des étiquettes de variables et des étiquettes de valeurs.

Que peut-on lire ?

* Tout d'abord notre objet a trois <dfn data-index="classe, objet">classes</dfn>.
  Il s'agit bien d'un tableau de données (`data.frame`) mais il a été « étendu » avec les classes
  `tbl_df` et `tbl`. À ce stade, cela nous importe peu. Disons juste que cela nous donnera accès à des
  fonctionnalités supplémentaires lorsqu'on nous aborderons l'extension `dplyr`{.pkg} dans le chapitre
  sur la [manipulation de données](pem_manipulation.html).
* Notre tableau de données contient 2000 observations et 17 variables.
* Les trois premières variables s'appellent respectivement <var>id_femme</var>, <var>id_menage</var> et
  <var>poids</var>. Il est facile de les identifier car leur nom est précédé du symbole `$`. Nous avons 
  également un aperçu des premières valeurs prises par ces variables, nous indiquant qu'elles sont de 
  type numérique.
* Les lignes commençant par `..- attr` correspondent à des <dfn data-index="attribut, objet">attributs</dfn>,
  c'est-à-dire à des méta-données sur ces variables, en l'occurence les étiquettes de variable.
* La quatrième et la cinquième variable (respectivement <var>date_entretien</var> et 
  <var>date_naissance</var>) de type `Date`.
* etc.

<div class="important">
La fonction `str`{data-pkg="utils"} est essentielle à connaître et peut s'appliquer à n'importe quel 
type d'objet. C'est un excellent moyen de connaître en détail la <dfn>structure d'un objet</dfn>.
Cependant, les résultats peuvent être parfois trop détaillés et on lui priviligiera dans certains
cas la fonction `describe`{data-pkg="questionr"}, cependant moins générique puisque ne s'appliquant
qu'à des tableaux de données et à des vecteurs, tandis que `str`{data-pkg="utils"} peut s'appliquer
à absolument **tout** objet, y compris des fonctions.
</div>

## La fonction describe

L'extension `questionr`{.pkg} fournit également une fonction bien pratique pour décrire les
différentes variables d'un tableau de données. Il s'agit de `describe`{data-pkg="questionr"}.
Faisons de suite un essai :

```{r}
describe(d)
```

Comme on le voit sur cet exemple, `describe`{data-pkg="questionr"} nous affiche, le cas échéant,
les étiquettes des différentes variables, leur type, les premières valeurs de chacune, le nombre
de valeurs manquantes, le nombre de valeurs différentes (uniques) ainsi que quelques autres informations
suivant le type de variables.

Il est possible de restreindre l'affichage à seulement quelques variables en indiquant le nom de ces dernières.

```{r}
describe(d, "age", "religion")
```

Pour d'autres exemples, on pourra se référer à l'aide de `describe`{data-pkg="questionr"} (accessible avec 
la commande `?describe`).

<div class="note">
Si c'est la première fois que lisez ce chapitre, sautez cette note. 

Pour les autres, vous aurez probablement déjà entendu parler de l'extension
`dplyr`{.pkg} abordée dans d'autres chapitres. Elle propose une fonction
`glimpse`{data-pkg="dplyr"} (ce qui signifie "aperçu" en anglais) qui
permet de visualiser rapidement et de manière condensée le contenu d'un
tableau de données.

```{r, message=FALSE}
library(dplyr)
```
```{r}
glimpse(d)
```

</div>

